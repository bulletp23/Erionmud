<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE muclient>
<muclient>
  <plugin
    name="Erion_Mapper_Display"
    author="Xalles"
    id="6572696F6E5F6D61705F6469"
    language="Lua"
    purpose="Visual miniwindow display for Erion mapper"
    date_written="2025-10-15"
    requires="4.59"
    version="3.1"
    save_state="y"
  >
    <description trim="y"><![CDATA[
===============================================================================
                      ERION MAPPER DISPLAY v3.1
===============================================================================

COMMANDS:
  mapdisplay help   - Show this help file
  mapzoom in        - Zoom in (bigger rooms)
  mapzoom out       - Zoom out (smaller rooms)

FEATURES:
  - Modern visual miniwindow showing rooms within 4 steps
  - Drag title bar to move window
  - Drag bottom-right corner to resize window
  - Purple asterisk (*) indicates rooms with custom exits
  - Grey angled lines show up/down exits
  - Hover over rooms to see details

LEGEND:
  Green border = Your current room
  Blue border = Neighboring rooms
  Purple * = Custom exit in this room
  Grey / = Up exit
  Grey \ = Down exit

CONTROLS:
  - mapzoom in/out  - Adjust room size
  - Drag title      - Move window
  - Drag corner     - Resize window

REQUIREMENTS:
  Requires Erion_Text_Mapper plugin to be installed and working.
  The display automatically updates when you move between rooms.

===============================================================================
]]>
    </description>
  </plugin>

  <aliases>
    <alias match="^mapdisplay help$" enabled="y" regexp="y" sequence="100" script="show_help">
    </alias>
    <alias match="^mapzoom (in|out|\+|\-)$" enabled="y" regexp="y" sequence="100" script="manual_zoom">
    </alias>
  </aliases>

  <triggers>
    <trigger enabled="y" regexp="y" match="\(Id\s+(\d+)\)" send_to="12" sequence="100" script="on_room_detect">
    </trigger>
  </triggers>

  <script>
  <![CDATA[
  require "movewindow"
  
  -- Configuration
  local WIN = {
    name = "erion_mapper_v3",
    w = tonumber(GetVariable("mapper_v3_w") or "600"),
    h = tonumber(GetVariable("mapper_v3_h") or "500"),
    
    -- Colors
    bg = 0x1a1a1a,
    title_bg = 0x2563eb,
    title_fg = 0xffffff,
    status_bg = 0x1e293b,
    current_room = 0x00ff00,
    other_room = 0x4a9eff,
    line_color = 0x888888,
    text_color = 0xe0e0e0,
    custom_exit = 0xff00ff,
    border = 0x334155,
    
    -- Layout
    title_h = 26,
    status_h = 44,
    room_size = tonumber(GetVariable("mapper_v3_room_size") or "30"),
    room_spacing = tonumber(GetVariable("mapper_v3_room_spacing") or "70"),
    min_width = 200,
    min_height = 200,
    max_width = 1200,
    max_height = 1000,
    min_room_size = 15,
    max_room_size = 60
  }
  
  -- State
  local current_room_id = nil
  local rooms = {}
  local windowinfo
  
  -- Direction positions
  local DIR_POS = {
    north = {0, -1},
    south = {0, 1},
    east = {1, 0},
    west = {-1, 0},
    northeast = {0.7, -0.7},
    northwest = {-0.7, -0.7},
    southeast = {0.7, 0.7},
    southwest = {-0.7, 0.7}
  }
  
  -- Load map data from file
  local function load_map_file()
    local world_dir = GetInfo(66) or ""
    if world_dir ~= "" and world_dir:sub(-1) ~= "\\" and world_dir:sub(-1) ~= "/" then
      world_dir = world_dir .. "/"
    end
    
    local map_file = world_dir .. "erion_map.lua"
    local f = io.open(map_file, "r")
    if not f then return false end
    f:close()
    
    local chunk, err = loadfile(map_file)
    if not chunk then return false end
    
    local ok, data = pcall(chunk)
    if not ok or type(data) ~= "table" then return false end
    
    rooms = data.rooms or {}
    return true
  end
  
  -- Draw a single room box
  local function draw_room_box(x, y, room_data, is_current)
    local size = WIN.room_size
    local color = is_current and WIN.current_room or WIN.other_room
    
    WindowRectOp(WIN.name, 2, x - size/2, y - size/2, x + size/2, y + size/2, WIN.bg)
    WindowRectOp(WIN.name, 1, x - size/2, y - size/2, x + size/2, y + size/2, color)
    
    if is_current then
      WindowRectOp(WIN.name, 1, x - size/2 + 1, y - size/2 + 1, x + size/2 - 1, y + size/2 - 1, color)
    end
    
    if room_data and room_data.exits then
      local has_custom = false
      for dir, _ in pairs(room_data.exits) do
        if dir:sub(1, 4) == "cmd:" then
          has_custom = true
          break
        end
      end
      
      if has_custom then
        WindowText(WIN.name, "font_normal", "*",
                   x + size/2 - 12, y - size/2 + 2,
                   x + size/2 - 2, y - size/2 + 12,
                   WIN.custom_exit)
      end
    end
  end
  
  -- Draw connection line
  local function draw_connection(x1, y1, x2, y2)
    WindowLine(WIN.name, x1, y1, x2, y2, WIN.line_color, 0, 2)
  end
  
  -- Main draw function
  function draw_display()
    local w, h = WIN.w, WIN.h
    local cx, cy = w / 2, h / 2
    
    -- Delete room hotspots
    local hotspots = WindowHotspotList(WIN.name)
    if hotspots and type(hotspots) == "table" then
      for _, hs in ipairs(hotspots) do
        if hs:match("^room_") then
          WindowDeleteHotspot(WIN.name, hs)
        end
      end
    end
    
    WindowRectOp(WIN.name, 2, 0, 0, w, h, WIN.bg)
    
    -- Title bar
    WindowGradient(WIN.name, 0, 0, w, WIN.title_h, WIN.title_bg, 0x1e40af, 2)
    WindowText(WIN.name, "font_title", "Erion Mapper", 12, 6, 0, 0, WIN.title_fg)
    
    local legend = "Purple*=Custom  /=Up  \\=Down"
    local legend_width = WindowTextWidth(WIN.name, "font_small", legend)
    WindowText(WIN.name, "font_small", legend, w - legend_width - 12, 8, 0, 0, WIN.title_fg)
    
    if not current_room_id or not rooms[current_room_id] then
      WindowText(WIN.name, "font_normal", "No map data - move to a room", 
                 50, h/2 - 10, w - 50, h/2 + 10, WIN.text_color)
      WindowShow(WIN.name, true)
      return
    end
    
    -- Build room positions
    local room_positions = {}
    local visited = {}
    local to_process = {{id = current_room_id, x = 0, y = 0, depth = 0}}
    
    local function is_position_available(x, y, room_id)
      local min_distance = 0.8
      for other_id, other_pos in pairs(room_positions) do
        if other_id ~= room_id then
          local dx = x - other_pos.x
          local dy = y - other_pos.y
          local distance = math.sqrt(dx * dx + dy * dy)
          if distance < min_distance then
            return false
          end
        end
      end
      return true
    end
    
    while #to_process > 0 do
      local current = table.remove(to_process, 1)
      local rid = current.id
      
      if not visited[rid] and current.depth <= 4 then
        if is_position_available(current.x, current.y, rid) then
          visited[rid] = true
          room_positions[rid] = {x = current.x, y = current.y, depth = current.depth}
          
          if rooms[rid] and rooms[rid].exits then
            for dir, dest_id in pairs(rooms[rid].exits) do
              if dest_id and dest_id ~= "-1" and rooms[dest_id] and dir ~= "up" and dir ~= "down" then
                local dir_lower = dir:lower()
                local pos = DIR_POS[dir_lower]
                
                if pos and not visited[dest_id] then
                  table.insert(to_process, {
                    id = dest_id,
                    x = current.x + pos[1],
                    y = current.y + pos[2],
                    depth = current.depth + 1
                  })
                end
              end
            end
          end
        end
      end
    end
    
    -- Draw connections
    for rid, pos_data in pairs(room_positions) do
      if rooms[rid] and rooms[rid].exits then
        for dir, dest_id in pairs(rooms[rid].exits) do
          if dest_id and dest_id ~= "-1" and room_positions[dest_id] and dir ~= "up" and dir ~= "down" then
            local dir_lower = dir:lower()
            local pos = DIR_POS[dir_lower]
            
            if pos then
              local start_x = cx + (pos_data.x * WIN.room_spacing)
              local start_y = cy + (pos_data.y * WIN.room_spacing)
              local dest_pos = room_positions[dest_id]
              local dest_x = cx + (dest_pos.x * WIN.room_spacing)
              local dest_y = cy + (dest_pos.y * WIN.room_spacing)
              
              local angle = math.atan2(dest_y - start_y, dest_x - start_x)
              local line_start_x = start_x + math.cos(angle) * (WIN.room_size / 2)
              local line_start_y = start_y + math.sin(angle) * (WIN.room_size / 2)
              local line_end_x = dest_x - math.cos(angle) * (WIN.room_size / 2)
              local line_end_y = dest_y - math.sin(angle) * (WIN.room_size / 2)
              
              draw_connection(line_start_x, line_start_y, line_end_x, line_end_y)
            end
          end
        end
      end
    end
    
    -- Draw rooms
    for rid, pos_data in pairs(room_positions) do
      local room_x = cx + (pos_data.x * WIN.room_spacing)
      local room_y = cy + (pos_data.y * WIN.room_spacing)
      local is_current = (rid == current_room_id)
      
      draw_room_box(room_x, room_y, rooms[rid], is_current)
      
      -- Up/down indicators
      if rooms[rid] and rooms[rid].exits then
        if rooms[rid].exits.up then
          local start_x = room_x + WIN.room_size/2 - 5
          local start_y = room_y - WIN.room_size/2 + 5
          WindowLine(WIN.name, start_x, start_y, start_x + 15, start_y - 15, WIN.line_color, 0, 2)
        end
        
        if rooms[rid].exits.down then
          local start_x = room_x - WIN.room_size/2 + 5
          local start_y = room_y + WIN.room_size/2 - 5
          WindowLine(WIN.name, start_x, start_y, start_x - 15, start_y + 15, WIN.line_color, 0, 2)
        end
      end
      
      -- Hotspot
      if rooms[rid] then
        local tooltip = string.format("%s (ID: %s)", rooms[rid].name or "Unknown", rid)
        
        if rooms[rid].exits then
          for exit_dir, exit_dest in pairs(rooms[rid].exits) do
            if exit_dir:sub(1, 4) == "cmd:" then
              local cmd = exit_dir:sub(5)
              tooltip = tooltip .. string.format("\nCustom: %s", cmd)
            end
          end
        end
        
        WindowAddHotspot(WIN.name, "room_" .. rid,
                         room_x - WIN.room_size/2, room_y - WIN.room_size/2,
                         room_x + WIN.room_size/2, room_y + WIN.room_size/2,
                         "", "", "", "", "",
                         tooltip,
                         0, 0)
      end
    end
    
    -- Status bar
    local status_y = h - WIN.status_h
    WindowRectOp(WIN.name, 2, 0, status_y, w, h, WIN.status_bg)
    WindowLine(WIN.name, 0, status_y, w, status_y, WIN.border, 0, 2)
    
    local current_rm = rooms[current_room_id]
    local area_name = "Unknown Area"
    local room_name = "Unknown"
    
    if current_rm then
      area_name = current_rm.area or "Unknown Area"
      room_name = current_rm.name or "Unknown"
    end
    
    WindowText(WIN.name, "font_small", area_name, 
               12, status_y + 4, w - 12, status_y + 18, WIN.text_color)
    
    local mid_y = status_y + 22
    WindowLine(WIN.name, 8, mid_y, w - 8, mid_y, WIN.border, 0, 1)
    
    local room_text = string.format("%s (ID: %s)", room_name, current_room_id)
    WindowText(WIN.name, "font_small", room_text, 
               12, mid_y + 4, w - 12, h - 4, WIN.text_color)
    
    -- Resize corner
    for i = 1, 3 do
      local offset = i * 5
      WindowLine(WIN.name, w - offset - 3, h - 4, w - 4, h - offset - 3, WIN.border, 0, 2)
    end
    
    WindowShow(WIN.name, true)
  end
  
  -- Room detection
  function on_room_detect(name, line, wildcards)
    local new_id = wildcards[1]
    if new_id and new_id ~= current_room_id then
      current_room_id = new_id
      load_map_file()
      draw_display()
    end
  end
  
  -- Show help
  function show_help(name, line, wildcards)
    Note(GetPluginInfo(GetPluginID(), 3))
  end
  
  -- Manual zoom
  function manual_zoom(name, line, wildcards)
    local direction = wildcards[1]
    if direction == "in" or direction == "+" then
      zoom_in(0, "")
      Note("Zoomed in to size: " .. WIN.room_size)
    elseif direction == "out" or direction == "-" then
      zoom_out(0, "")
      Note("Zoomed out to size: " .. WIN.room_size)
    end
  end
  
  -- Zoom functions
  function zoom_in(flags, hotspot_id)
    WIN.room_size = math.min(WIN.max_room_size, WIN.room_size + 3)
    WIN.room_spacing = math.min(WIN.max_room_size * 2.5, WIN.room_spacing + 7)
    SetVariable("mapper_v3_room_size", tostring(WIN.room_size))
    SetVariable("mapper_v3_room_spacing", tostring(WIN.room_spacing))
    draw_display()
  end
  
  function zoom_out(flags, hotspot_id)
    WIN.room_size = math.max(WIN.min_room_size, WIN.room_size - 3)
    WIN.room_spacing = math.max(WIN.min_room_size * 2.5, WIN.room_spacing - 7)
    SetVariable("mapper_v3_room_size", tostring(WIN.room_size))
    SetVariable("mapper_v3_room_spacing", tostring(WIN.room_spacing))
    draw_display()
  end
  
  -- Resize
  local startx = 0
  local starty = 0
  
  function ResizeMoveCallback()
    local posx = WindowInfo(WIN.name, 17)
    local posy = WindowInfo(WIN.name, 18)
    
    local new_w = math.max(WIN.min_width, math.min(WIN.max_width, WIN.w + (posx - startx)))
    local new_h = math.max(WIN.min_height, math.min(WIN.max_height, WIN.h + (posy - starty)))
    
    if new_w ~= WIN.w or new_h ~= WIN.h then
      WIN.w = new_w
      WIN.h = new_h
      startx = posx
      starty = posy
      WindowResize(WIN.name, WIN.w, WIN.h, WIN.bg)
      
      local resize_size = 20
      WindowMoveHotspot(WIN.name, "resize_handle",
                       WIN.w - resize_size, WIN.h - resize_size,
                       WIN.w, WIN.h)
      
      draw_display()
    end
  end
  
  function ResizeReleaseCallback()
    SetVariable("mapper_v3_w", tostring(WIN.w))
    SetVariable("mapper_v3_h", tostring(WIN.h))
    movewindow.save_state(WIN.name)
  end
  
  function resize_start(flags, hotspot_id)
    startx = WindowInfo(WIN.name, 17)
    starty = WindowInfo(WIN.name, 18)
  end
  
  -- Plugin lifecycle
  function OnPluginInstall()
    Note("Erion Mapper Display v3.1 - Multi-level view")
    
    load_map_file()
    
    local POS = (miniwin and miniwin.create_absolute_location) or 0
    windowinfo = movewindow.install(WIN.name, miniwin.pos_top_right or 0, POS, true)
    
    WindowCreate(WIN.name, 
                 windowinfo.window_left or 0,
                 windowinfo.window_top or 0,
                 WIN.w, WIN.h,
                 windowinfo.window_mode or 0,
                 windowinfo.window_flags or 0,
                 WIN.bg)
    
    WindowFont(WIN.name, "font_normal", "Consolas", 9, false, false, false, false, 0, 0)
    WindowFont(WIN.name, "font_title", "Consolas", 10, true, false, false, false, 0, 0)
    WindowFont(WIN.name, "font_small", "Consolas", 8, false, false, false, false, 0, 0)
    
    movewindow.add_drag_handler(WIN.name, 0, 0, 0, WIN.title_h)
    
    WindowAddHotspot(WIN.name, "wheel_zone",
                     0, WIN.title_h,
                     WIN.w, WIN.h - WIN.status_h,
                     "", "", "", "", "",
                     "Use: mapzoom in/out to adjust size",
                     0, 0)
    WindowScrollwheelHandler(WIN.name, "wheel_zone", "zoom_in", "zoom_out")
    
    local resize_size = 20
    WindowAddHotspot(WIN.name, "resize_handle",
                     WIN.w - resize_size, WIN.h - resize_size,
                     WIN.w, WIN.h,
                     "", "", "resize_start", "", "",
                     "Drag to resize",
                     miniwin.cursor_nw_se_arrow or 15, 0)
    WindowDragHandler(WIN.name, "resize_handle", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
    
    WindowShow(WIN.name, true)
    draw_display()
    
    Note("Mapper Display ready - move to see map")
  end
  
  function OnPluginEnable()
    WindowShow(WIN.name, true)
  end
  
  function OnPluginDisable()
    WindowShow(WIN.name, false)
  end
  ]]>
  </script>

</muclient>