<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE muclient>
<muclient>
  <plugin
    name="Erion_Mapper_Display_SQLite"
    author="Wulfgar"
    id="6572696F6E5F6D61705F6469"
    language="Lua"
    purpose="Visual miniwindow display for Erion SQLite mapper"
    date_written="2025-10-19"
    requires="4.59"
    version="4.2"
    save_state="y"
  >
    <description trim="y"><![CDATA[
===============================================================================
                      ERION MAPPER DISPLAY v4.2 - SQLite Edition
===============================================================================

COMMANDS:
  mapdisplay help   - Show this help file
  mapzoom in        - Zoom in (bigger rooms)
  mapzoom out       - Zoom out (smaller rooms)
  mapdisplay reload - Force reload from database
  mapdisplay debug  - Test database connection
  mapdisplay status - Show window status

FEATURES:
  - Shows ALL rooms in your current area at once
  - Connected rooms positioned by their exits
  - Disconnected rooms shown in grid on the right side
  - Drag title bar to move window
  - Drag bottom-right corner to resize window
  - Purple asterisk (*) indicates rooms with custom exits
  - Grey angled lines show up/down exits
  - Hover over rooms to see details
  - Auto-updates from SQLite database

LEGEND:
  Green border = Your current room
  Cyan border = Exit to different area
  Purple * = Custom exit in this room

CONTROLS:
  - mapzoom in/out  - Adjust room size
  - Drag title      - Move window
  - Drag corner     - Resize window

===============================================================================
]]>
    </description>
  </plugin>

  <aliases>
    <alias match="^mapdisplay help$" enabled="y" regexp="y" sequence="100" script="show_help">
    </alias>
    <alias match="^mapzoom (in|out|\+|\-)$" enabled="y" regexp="y" sequence="100" script="manual_zoom">
    </alias>
    <alias match="^mapdisplay reload$" enabled="y" regexp="y" sequence="100" script="force_reload">
    </alias>
    <alias match="^mapdisplay debug$" enabled="y" regexp="y" sequence="100" script="debug_database">
    </alias>
    <alias match="^mapdisplay status$" enabled="y" regexp="y" sequence="100" script="show_status">
    </alias>
    <alias match="^mapdisplay sync$" enabled="y" regexp="y" sequence="100" script="force_sync">
    </alias>
  </aliases>

  <triggers>
    <trigger enabled="y" regexp="y" match="\(Id\s+(\d+)\)" send_to="12" sequence="100" script="on_room_detect">
    </trigger>
  </triggers>

  <script>
  <![CDATA[
  require "movewindow"
  
  -- Configuration
  local WIN = {
    name = "erion_mapper_v4",
    w = tonumber(GetVariable("mapper_v4_w") or "600"),
    h = tonumber(GetVariable("mapper_v4_h") or "500"),
    
    -- Colors
    bg = 0x1a1a1a,              -- Dark grey background (back to original)
    title_bg = 0x2563eb,
    title_fg = 0xffffff,
    status_bg = 0x1e293b,
    current_room = 0x00ff00,    -- Green (stays the same)
    other_room = 0xc0c0c0,      -- Dull white/light gray for normal rooms
    boundary_room = 0xffff00,   -- Cyan (BGR: full blue, full green, no red = cyan)
    line_color = 0x888888,
    text_color = 0xe0e0e0,
    custom_exit = 0xff00ff,
    border = 0x334155,
    
    -- Layout
    title_h = 26,
    status_h = 44,
    room_size = tonumber(GetVariable("mapper_v4_room_size") or "30"),
    room_spacing = tonumber(GetVariable("mapper_v4_room_spacing") or "52"),  -- Reduced from 70 to 52 (25% reduction)
    min_width = 200,
    min_height = 200,
    max_width = 1200,
    max_height = 1000,
    min_room_size = 10,
    max_room_size = 50
  }
  
  -- State
  local current_room_id = nil
  local rooms = {}
  local windowinfo
  local db_id = "erion_mapper_db"
  local display_debug = false
  
  -- Direction vectors for positioning
  local DIR_OFFSET = {
    north = {x = 0, y = -1},
    south = {x = 0, y = 1},
    east = {x = 1, y = 0},
    west = {x = -1, y = 0},
    northeast = {x = 1, y = -1},
    northwest = {x = -1, y = -1},
    southeast = {x = 1, y = 1},
    southwest = {x = -1, y = 1}
  }
  
  -- Get database path
  local function db_path()
    local world_dir = GetInfo(66) or ""
    world_dir = world_dir:gsub("\\", "/")
    if world_dir ~= "" and world_dir:sub(-1) ~= "/" then
      world_dir = world_dir .. "/"
    end
    return world_dir .. "erion_map.db"
  end
  
  -- Check if database exists
  local function db_exists()
    local path = db_path()
    local f = io.open(path, "r")
    if f then
      f:close()
      return true
    end
    return false
  end
  
  -- Initialize database connection
  local function db_init()
    local path = db_path()
    local rc = DatabaseOpen(db_id, path)
    if rc ~= 0 then
      Note("Display ERROR: Could not open database. Error code: " .. rc)
      return false
    end
    return true
  end
  
  -- SQL escape function
  local function fixsql(s)
    if not s then return "NULL" end
    s = tostring(s)
    s = s:gsub("'", "''")
    return "'" .. s .. "'"
  end
  
  -- Load specific room from database
  local function load_room_from_db(uid)
    if not uid then return nil end
    
    local room = {
      uid = uid,
      name = "Unknown",
      area = "Unknown",
      exits = {},
      exit_locks = {}
    }
    
    local query = string.format("SELECT name, area FROM rooms WHERE uid = %s", fixsql(uid))
    local stmt = DatabasePrepare(db_id, query)
    
    if stmt then
      if DatabaseStep(db_id) == sqlite3.ROW then
        room.name = DatabaseColumnText(db_id, 1) or "Unknown"
        room.area = DatabaseColumnText(db_id, 2) or "Unknown"
      end
      DatabaseFinalize(db_id)
    end
    
    local exit_query = string.format("SELECT direction, to_uid, is_locked FROM exits WHERE from_uid = %s", fixsql(uid))
    stmt = DatabasePrepare(db_id, exit_query)
    
    if stmt then
      while DatabaseStep(db_id) == sqlite3.ROW do
        local dir = DatabaseColumnText(db_id, 1)
        local to_uid = DatabaseColumnText(db_id, 2)
        local is_locked = DatabaseColumnValue(db_id, 3)
        
        room.exits[dir] = to_uid
        if is_locked == 1 then
          room.exit_locks[dir] = true
        end
      end
      DatabaseFinalize(db_id)
    end
    
    return room
  end
  
  -- Load all rooms in current area PLUS boundary rooms from adjacent areas
  local function load_area_rooms(center_uid)
    if not center_uid then return {} end
    
    local loaded = {}
    local current_room = load_room_from_db(center_uid)
    if not current_room then return {} end
    
    local current_area = current_room.area
    loaded[center_uid] = current_room
    
    local query = string.format("SELECT uid FROM rooms WHERE area = %s", fixsql(current_area))
    local stmt = DatabasePrepare(db_id, query)
    
    if stmt then
      local all_uids = {}
      while DatabaseStep(db_id) == sqlite3.ROW do
        local uid = DatabaseColumnText(db_id, 1)
        if uid then
          table.insert(all_uids, uid)
        end
      end
      DatabaseFinalize(db_id)
      
      for _, uid in ipairs(all_uids) do
        if uid ~= center_uid then
          loaded[uid] = load_room_from_db(uid)
        end
      end
    end
    
    -- Now find boundary rooms (rooms in other areas that connect to this area)
    local boundary_rooms = {}
    for uid, room_data in pairs(loaded) do
      if room_data.exits then
        for dir, dest_uid in pairs(room_data.exits) do
          if dest_uid and dest_uid ~= "-1" and not loaded[dest_uid] then
            -- This exit goes to a room we haven't loaded yet
            local dest_room = load_room_from_db(dest_uid)
            if dest_room and dest_room.area ~= current_area then
              -- It's in a different area - mark it as a boundary room
              dest_room.is_boundary = true
              boundary_rooms[dest_uid] = dest_room
            end
          end
        end
      end
    end
    
    -- Add boundary rooms to loaded set
    for uid, room_data in pairs(boundary_rooms) do
      loaded[uid] = room_data
    end
    
    return loaded
  end
  
  -- Reload rooms from database
  local function reload_rooms()
    if not current_room_id then
      rooms = {}
      return false
    end
    
    if not db_exists() then
      rooms = {}
      return false
    end
    
    if not db_init() then
      rooms = {}
      return false
    end
    
    rooms = load_area_rooms(current_room_id)
    return true
  end
  
  -- Debug database connection
  function debug_database()
    Note("================================================================================")
    Note("MAPPER DISPLAY DEBUG")
    Note("================================================================================")
    Note("Database path: " .. db_path())
    Note("Database exists: " .. tostring(db_exists()))
    Note("Current room ID: " .. tostring(current_room_id))
    
    if db_exists() and db_init() then
      local stmt = DatabasePrepare(db_id, "SELECT COUNT(*) FROM rooms")
      if stmt then
        if DatabaseStep(db_id) == sqlite3.ROW then
          Note("Total rooms in database: " .. DatabaseColumnValue(db_id, 1))
        end
        DatabaseFinalize(db_id)
      end
      
      stmt = DatabasePrepare(db_id, "SELECT COUNT(*) FROM exits")
      if stmt then
        if DatabaseStep(db_id) == sqlite3.ROW then
          Note("Total exits in database: " .. DatabaseColumnValue(db_id, 1))
        end
        DatabaseFinalize(db_id)
      end
      
      if current_room_id then
        local room = load_room_from_db(current_room_id)
        if room then
          Note("Current room: " .. room.name)
          Note("Current area: " .. room.area)
          local exit_count = 0
          for _ in pairs(room.exits) do exit_count = exit_count + 1 end
          Note("Current room exits: " .. exit_count)
        end
      end
      
      local loaded_count = 0
      for _ in pairs(rooms) do loaded_count = loaded_count + 1 end
      Note("Rooms currently loaded in display: " .. loaded_count)
    end
    
    Note("================================================================================")
    display_debug = not display_debug
    Note("Display debug mode: " .. (display_debug and "ON" or "OFF"))
  end
  
  -- Show window status
  function show_status()
    Note("================================================================================")
    Note("MAPPER DISPLAY STATUS")
    Note("================================================================================")
    Note("Window size: " .. WIN.w .. " x " .. WIN.h)
    Note("Current room ID: " .. tostring(current_room_id))
    
    local room_count = 0
    for _ in pairs(rooms) do room_count = room_count + 1 end
    Note("Rooms loaded: " .. room_count)
    
    if current_room_id and rooms[current_room_id] then
      Note("Current room: " .. rooms[current_room_id].name)
      Note("Current area: " .. rooms[current_room_id].area)
    end
    
    Note("Room size: " .. WIN.room_size)
    Note("================================================================================")
  end
  
  -- Calculate room positions using grid layout
  local function calculate_positions()
    if not current_room_id or not rooms[current_room_id] then
      return {}
    end
    
    local positions = {}
    local visited = {}
    
    -- Start with current room at origin
    positions[current_room_id] = {x = 0, y = 0}
    visited[current_room_id] = true
    
    -- BFS to position connected rooms
    local queue = {current_room_id}
    
    while #queue > 0 do
      local current_uid = table.remove(queue, 1)
      local current_pos = positions[current_uid]
      local current_room = rooms[current_uid]
      
      if current_room and current_room.exits then
        for dir, dest_uid in pairs(current_room.exits) do
          -- Skip up/down, unexplored, and already visited
          if dest_uid ~= "-1" and rooms[dest_uid] and not visited[dest_uid] and dir ~= "up" and dir ~= "down" then
            local offset = DIR_OFFSET[dir:lower()]
            
            if offset then
              -- Calculate new position
              local new_x = current_pos.x + offset.x
              local new_y = current_pos.y + offset.y
              
              -- Check if position is already occupied
              local position_occupied = false
              for other_uid, other_pos in pairs(positions) do
                if other_pos.x == new_x and other_pos.y == new_y then
                  position_occupied = true
                  if display_debug then
                    Note(string.format("WARNING: Position (%d,%d) already occupied by room %s, skipping room %s via %s", 
                         new_x, new_y, other_uid, dest_uid, dir))
                  end
                  break
                end
              end
              
              if not position_occupied then
                positions[dest_uid] = {x = new_x, y = new_y}
                visited[dest_uid] = true
                table.insert(queue, dest_uid)
              end
            end
          end
        end
      end
    end
    
    -- Position disconnected rooms in a grid
    local disconnected = {}
    for uid, _ in pairs(rooms) do
      if not positions[uid] then
        table.insert(disconnected, uid)
      end
    end
    
    -- Don't display disconnected rooms - just remove them from the rooms table
    for _, uid in ipairs(disconnected) do
      rooms[uid] = nil
    end
    
    return positions
  end
  
  -- Draw a single room
  local function draw_room(x, y, room_data, is_current)
    local size = WIN.room_size
    local color
    
    if is_current then
      color = WIN.current_room
    elseif room_data and room_data.is_boundary then
      color = WIN.boundary_room  -- Cyan for boundary rooms
    else
      color = WIN.other_room
    end
    
    -- Fill
    WindowRectOp(WIN.name, 2, x - size/2, y - size/2, x + size/2, y + size/2, WIN.bg)
    -- Border
    WindowRectOp(WIN.name, 1, x - size/2, y - size/2, x + size/2, y + size/2, color)
    
    -- Double border for current room
    if is_current then
      WindowRectOp(WIN.name, 1, x - size/2 + 1, y - size/2 + 1, x + size/2 - 1, y + size/2 - 1, color)
    end
    
    -- Custom exit indicator
    if room_data and room_data.exits then
      for dir, _ in pairs(room_data.exits) do
        if dir:sub(1, 4) == "cmd:" then
          WindowText(WIN.name, "font_normal", "*",
                     x + size/2 - 10, y - size/2 + 2,
                     x + size/2, y - size/2 + 12,
                     WIN.custom_exit)
          break
        end
      end
    end
  end
  
  -- Main draw function
  function draw_display()
    local w, h = WIN.w, WIN.h
    
    -- Clear window
    WindowRectOp(WIN.name, 2, 0, 0, w, h, WIN.bg)
    
    -- Title bar
    WindowGradient(WIN.name, 0, 0, w, WIN.title_h, WIN.title_bg, 0x1e40af, 2)
    WindowText(WIN.name, "font_title", "Erion Mapper", 12, 6, 0, 0, WIN.title_fg)
    
    local legend = "Cyan=Area Exit  Purple*=Custom"
    local legend_width = WindowTextWidth(WIN.name, "font_small", legend)
    WindowText(WIN.name, "font_small", legend, w - legend_width - 12, 8, 0, 0, WIN.title_fg)
    
    if not current_room_id or not rooms[current_room_id] then
      local msg = "No map data - move to a room or type 'mapdisplay reload'"
      WindowText(WIN.name, "font_normal", msg, 
                 20, h/2 - 10, w - 20, h/2 + 10, WIN.text_color)
      WindowShow(WIN.name, true)
      return
    end
    
    -- Calculate room positions
    local grid_positions = calculate_positions()
    
    -- Convert grid positions to screen positions using FIXED spacing
    local center_x = w / 2
    local center_y = (h - WIN.status_h + WIN.title_h) / 2
    
    local screen_positions = {}
    for uid, grid_pos in pairs(grid_positions) do
      screen_positions[uid] = {
        x = center_x + (grid_pos.x * WIN.room_spacing),
        y = center_y + (grid_pos.y * WIN.room_spacing)
      }
    end
    
    -- Draw connections
    for uid, screen_pos in pairs(screen_positions) do
      local room = rooms[uid]
      if room and room.exits then
        for dir, dest_uid in pairs(room.exits) do
          if dest_uid ~= "-1" and screen_positions[dest_uid] and dir ~= "up" and dir ~= "down" then
            local dest_pos = screen_positions[dest_uid]
            
            -- Calculate line from edge to edge
            local dx = dest_pos.x - screen_pos.x
            local dy = dest_pos.y - screen_pos.y
            local dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0 then
              local offset = WIN.room_size / 2
              local start_x = screen_pos.x + (dx / dist) * offset
              local start_y = screen_pos.y + (dy / dist) * offset
              local end_x = dest_pos.x - (dx / dist) * offset
              local end_y = dest_pos.y - (dy / dist) * offset
              
              WindowLine(WIN.name, start_x, start_y, end_x, end_y, WIN.line_color, 0, 2)
            end
          end
        end
      end
    end
    
    -- Define drawable area bounds (excluding title and status bars, with padding)
    local draw_top = WIN.title_h + 5
    local draw_bottom = h - WIN.status_h - 5
    local draw_left = 5
    local draw_right = w - 5
    
    -- Draw rooms (with strict clipping check)
    for uid, screen_pos in pairs(screen_positions) do
      -- Only draw if room center is within visible bounds
      -- This prevents partial rooms from appearing at edges
      if screen_pos.x >= (draw_left + WIN.room_size/2) and 
         screen_pos.x <= (draw_right - WIN.room_size/2) and
         screen_pos.y >= (draw_top + WIN.room_size/2) and 
         screen_pos.y <= (draw_bottom - WIN.room_size/2) then
        
        local is_current = (uid == current_room_id)
        draw_room(screen_pos.x, screen_pos.y, rooms[uid], is_current)
      
        -- Up/down indicators
        if rooms[uid] and rooms[uid].exits then
          if rooms[uid].exits.up then
            local x = screen_pos.x + WIN.room_size/2 - 5
            local y = screen_pos.y - WIN.room_size/2 + 5
            WindowLine(WIN.name, x, y, x + 10, y - 10, WIN.line_color, 0, 2)
          end
          
          if rooms[uid].exits.down then
            local x = screen_pos.x - WIN.room_size/2 + 5
            local y = screen_pos.y + WIN.room_size/2 - 5
            WindowLine(WIN.name, x, y, x - 10, y + 10, WIN.line_color, 0, 2)
          end
        end
        
        -- Hotspot
        if rooms[uid] then
          local tooltip = string.format("%s (ID: %s)", rooms[uid].name, uid)
          if rooms[uid].exits then
            for dir, _ in pairs(rooms[uid].exits) do
              if dir:sub(1, 4) == "cmd:" then
                tooltip = tooltip .. "\nCustom: " .. dir:sub(5)
              end
            end
          end
          
          WindowAddHotspot(WIN.name, "room_" .. uid,
                           screen_pos.x - WIN.room_size/2, screen_pos.y - WIN.room_size/2,
                           screen_pos.x + WIN.room_size/2, screen_pos.y + WIN.room_size/2,
                           "", "", "", "", "", tooltip, 0, 0)
        end
      end
    end
    
    -- Status bar
    local status_y = h - WIN.status_h
    WindowRectOp(WIN.name, 2, 0, status_y, w, h, WIN.status_bg)
    WindowLine(WIN.name, 0, status_y, w, status_y, WIN.border, 0, 2)
    
    local current_rm = rooms[current_room_id]
    if current_rm then
      WindowText(WIN.name, "font_small", current_rm.area or "Unknown Area", 
                 12, status_y + 4, w - 12, status_y + 18, WIN.text_color)
      
      local mid_y = status_y + 22
      WindowLine(WIN.name, 8, mid_y, w - 8, mid_y, WIN.border, 0, 1)
      
      local room_text = string.format("%s (ID: %s)", current_rm.name, current_room_id)
      WindowText(WIN.name, "font_small", room_text, 
                 12, mid_y + 4, w - 12, h - 4, WIN.text_color)
    end
    
    -- Resize corner indicator
    for i = 1, 3 do
      local offset = i * 5
      WindowLine(WIN.name, w - offset - 3, h - 4, w - 4, h - offset - 3, WIN.border, 0, 2)
    end
    
    WindowShow(WIN.name, true)
  end
  
  -- Room detection
  function on_room_detect(name, line, wildcards)
    local new_id = wildcards[1]
    if new_id and new_id ~= current_room_id then
      current_room_id = new_id
      reload_rooms()
      draw_display()
    end
  end
  
  -- Try to sync with main mapper
  local function sync_with_mapper()
    if GetCurrentRoom then
      local mapper_room = GetCurrentRoom()
      if mapper_room then
        current_room_id = mapper_room
        reload_rooms()
        draw_display()
        return true
      end
    end
    return false
  end
  
  -- Force sync
  function force_sync()
    if sync_with_mapper() then
      Note("Display synced with mapper plugin")
    else
      Note("Could not sync - try moving to a room or typing 'look'")
    end
  end
  
  -- Force reload
  function force_reload()
    reload_rooms()
    draw_display()
    Note("Mapper display reloaded from database")
  end
  
  -- Show help
  function show_help()
    Note(GetPluginInfo(GetPluginID(), 3))
  end
  
  -- Manual zoom
  function manual_zoom(name, line, wildcards)
    local direction = wildcards[1]
    if direction == "in" or direction == "+" then
      WIN.room_size = math.min(WIN.max_room_size, WIN.room_size + 3)
      WIN.room_spacing = math.min(WIN.max_room_size * 2.5, WIN.room_spacing + 7)
      SetVariable("mapper_v4_room_size", tostring(WIN.room_size))
      SetVariable("mapper_v4_room_spacing", tostring(WIN.room_spacing))
      draw_display()
      Note("Zoomed in - room size: " .. WIN.room_size .. ", spacing: " .. WIN.room_spacing)
    elseif direction == "out" or direction == "-" then
      WIN.room_size = math.max(WIN.min_room_size, WIN.room_size - 3)
      WIN.room_spacing = math.max(WIN.min_room_size * 2.5, WIN.room_spacing - 7)
      SetVariable("mapper_v4_room_size", tostring(WIN.room_size))
      SetVariable("mapper_v4_room_spacing", tostring(WIN.room_spacing))
      draw_display()
      Note("Zoomed out - room size: " .. WIN.room_size .. ", spacing: " .. WIN.room_spacing)
    end
  end
  
  -- Resize callbacks
  local startx = 0
  local starty = 0
  
  function ResizeMoveCallback()
    local posx = WindowInfo(WIN.name, 17)
    local posy = WindowInfo(WIN.name, 18)
    
    local new_w = math.max(WIN.min_width, math.min(WIN.max_width, WIN.w + (posx - startx)))
    local new_h = math.max(WIN.min_height, math.min(WIN.max_height, WIN.h + (posy - starty)))
    
    if new_w ~= WIN.w or new_h ~= WIN.h then
      WIN.w = new_w
      WIN.h = new_h
      startx = posx
      starty = posy
      WindowResize(WIN.name, WIN.w, WIN.h, WIN.bg)
      
      WindowMoveHotspot(WIN.name, "resize_handle",
                       WIN.w - 20, WIN.h - 20, WIN.w, WIN.h)
      
      draw_display()
    end
  end
  
  function ResizeReleaseCallback()
    SetVariable("mapper_v4_w", tostring(WIN.w))
    SetVariable("mapper_v4_h", tostring(WIN.h))
    movewindow.save_state(WIN.name)
  end
  
  function resize_start()
    startx = WindowInfo(WIN.name, 17)
    starty = WindowInfo(WIN.name, 18)
  end
  
  -- Plugin lifecycle
  function OnPluginInstall()
    Note("================================================================================")
    Note("Erion Mapper Display v4.2 - SQLite Edition")
    Note("================================================================================")
    
    if db_exists() and db_init() then
      Note("Database connection successful!")
      if sync_with_mapper() then
        Note("Synced with mapper plugin")
      end
    else
      Note("Waiting for database...")
    end
    
    local POS = (miniwin and miniwin.create_absolute_location) or 0
    windowinfo = movewindow.install(WIN.name, miniwin.pos_top_right or 0, POS, true)
    
    WindowCreate(WIN.name, 
                 windowinfo.window_left or 0,
                 windowinfo.window_top or 0,
                 WIN.w, WIN.h,
                 windowinfo.window_mode or 0,
                 windowinfo.window_flags or 0,
                 WIN.bg)
    
    WindowFont(WIN.name, "font_normal", "Consolas", 9, false, false, false, false, 0, 0)
    WindowFont(WIN.name, "font_title", "Consolas", 10, true, false, false, false, 0, 0)
    WindowFont(WIN.name, "font_small", "Consolas", 8, false, false, false, false, 0, 0)
    
    movewindow.add_drag_handler(WIN.name, 0, 0, 0, WIN.title_h)
    
    WindowAddHotspot(WIN.name, "resize_handle",
                     WIN.w - 20, WIN.h - 20, WIN.w, WIN.h,
                     "", "", "resize_start", "", "",
                     "Drag to resize",
                     miniwin.cursor_nw_se_arrow or 15, 0)
    WindowDragHandler(WIN.name, "resize_handle", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
    
    draw_display()
    
    Note("Type 'mapdisplay help' for commands")
    Note("================================================================================")
  end
  
  function OnPluginEnable()
    WindowShow(WIN.name, true)
  end
  
  function OnPluginDisable()
    WindowShow(WIN.name, false)
  end
  
  function OnPluginClose()
    DatabaseClose(db_id)
  end
  ]]>
  </script>

</muclient>