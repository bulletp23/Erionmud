<?xml version="1.0" encoding="UTF-8"?>
<muclient>
  <plugin
    name="Erion_Quest_Tracker"
    author="Wulfgar"
    id="696a2c2fd6a84f39a2e24f69"
    language="Lua"
    purpose="Erion quest tracker: grid with clickable Area/Room/Mob names and expeditions."
    date_written="2025-10-14"
    requires="4.94"
    version="1.64"
    save_state="y"
  >
    <description><![CDATA[
      v18.04 - Scan/Oscan Complete Rewrite
        • FIXED: Oscan #quest now properly detects and highlights junkyard items
        • FIXED: Scan @qt now properly captures mob lines with all formats
        • FIXED: Type-based trigger activation (junkyard → oscan, mobs → scan)
        • IMPROVED: Dual trigger system for maximum compatibility
    ]]>
	</description>
  </plugin>

  <aliases>
    <alias match="^qt\b(.*)$" enabled="y" sequence="100" send_to="12" regexp="y" omit_from_output="y">
      <send>qt_cmd("%1")</send>
    </alias>
  </aliases>

  <triggers>
    <!-- Quest request detection -->
    <trigger match="^You ask The Giver for a quest\.$" script="qt_on_quest_request" enabled="y" regexp="y" sequence="100"/>
    <trigger match="^You ask The Giver for a junkyard quest\.$" script="qt_on_junkyard_request" enabled="y" regexp="y" sequence="100"/>
    <trigger match="^You ask The Giver for an expedition\.$" script="qt_on_expedition_request" enabled="y" regexp="y" sequence="100"/>
    
    <!-- Global Quest -->
    <trigger match="^Global Quest:.+$" script="qt_parse_quest" enabled="y" regexp="y"/>
    
    <!-- Global Quest Win Clear -->
    <trigger match="^You WIN your \d+(?:st|nd|rd|th) global quest!!!\s*$" script="qt_global_win" enabled="y" regexp="y" sequence="100"/>
    
    <!-- Quest info response (gag the output) -->
    <trigger match="^You are on a quest to .+ in the vicinity of (.+) of (.+)\.$" script="qt_parse_quest_info" enabled="y" regexp="y" omit_from_output="y"/>
    <trigger match="^You are on a quest to .+ in the vicinity of (.+) in (.+)\.$" script="qt_parse_quest_info" enabled="y" regexp="y" omit_from_output="y"/>
    <trigger match="^You are on a quest to .+ in (.+) of (.+)\.$" script="qt_parse_quest_info" enabled="y" regexp="y" omit_from_output="y"/>
    <trigger match="^You are on a quest to .+ in (.+) in (.+)\.$" script="qt_parse_quest_info" enabled="y" regexp="y" omit_from_output="y"/>
    
    <!-- Gag "not on quest" message -->
    <trigger match="^You aren't currently on a quest\.$" enabled="y" regexp="y" omit_from_output="y" script="qt_gag_no_quest"/>
    
    <!-- Junkyard Quest markers -->
    <trigger match="^Junkyard Quest:.+$" script="qt_parse_quest" enabled="y" regexp="y" sequence="50"/>
    
    <!-- Timed Junkyard Quest (list format) -->
    <trigger name="qt_jy_begin" match="^You have .+ left to gather:$" script="qt_jy_begin" enabled="y" regexp="y"/>
    <trigger name="qt_jy_line" match="^\[\s*\d+\]\s+.+$" script="qt_jy_line" enabled="n" regexp="y"/>
    <trigger name="qt_jy_cont" match="^.+$" script="qt_jy_cont" enabled="n" regexp="y"/>
    <trigger name="qt_jy_end" match="^$" script="qt_jy_end" enabled="n" regexp="y"/>
    
    <!-- Global Quest targets (list format) -->
    <trigger name="qt_gq_begin" match="^Quest targets\s*:\s*$" script="qt_gq_begin" enabled="y" regexp="y" sequence="50"/>
    <trigger name="qt_gq_line" match="^\s*\d+\.\s+.+$" script="qt_gq_line" enabled="n" regexp="y" sequence="50"/>
    <trigger name="qt_gq_end" match="^$" script="qt_gq_end" enabled="n" regexp="y" sequence="50"/>

    <!-- Expeditions block -->
    <trigger match="Expedition\s+Targets" script="qt_exp_begin" enabled="y" regexp="y"/>
    <trigger match="^\s*Find\s+and\s+kill\s+.+\s+in\s+.+" script="qt_exp_line" enabled="y" regexp="y"/>
    <trigger match="^\s*[-]+\s*$" script="qt_exp_end" enabled="y" regexp="y"/>

    <!-- Global Junkyards -->
    <trigger name="qt_gjy_begin" match="^\s*Junkyard\s+Items\s*:\s*$" script="qt_gjy_begin" enabled="y" regexp="y" sequence="100"/>
    <trigger name="qt_gjy_line"  match="^\s*\d+\.\s+.*$" script="qt_gjy_line" enabled="n" regexp="y" sequence="100"/>
    <trigger name="qt_gjy_cont"  match="^\s*(?!\d+\.\s).*?[Ii]n.*$" script="qt_gjy_cont" enabled="n" regexp="y" sequence="100"/>

    <!-- Death removal -->
    <trigger match="^\s*(.+)\s+is\s+dead!\s*(?:R\.I\.P\.)?\s*$" script="qt_on_death" enabled="y" regexp="y"/>
    
    <!-- Quest turn-in detection -->
    <trigger match="^You inform The Giver you have completed your quest\.$" script="qt_on_quest_turnin" enabled="y" regexp="y"/>
    <trigger match="^You inform The Giver you have completed your expedition\.$" script="qt_on_quest_turnin" enabled="y" regexp="y"/>
    <trigger match="^You inform The Giver you have completed your junkyard quest\.$" script="qt_on_quest_turnin" enabled="y" regexp="y"/>
    <trigger match="^You inform The Giver you have finished eliminating hazardous remnants from the world\.$" script="qt_on_quest_turnin" enabled="y" regexp="y"/>
    
    <!-- Item pickup detection -->
    <trigger match="^You get (.+)\.$" script="qt_on_item_pickup" enabled="y" regexp="y"/>
    <trigger match="^You get (.+) from .+$" script="qt_on_item_pickup" enabled="y" regexp="y"/>
    <trigger match="^You pick up (.+)\.$" script="qt_on_item_pickup" enabled="y" regexp="y"/>
    <trigger match="^You take (.+)\.$" script="qt_on_item_pickup" enabled="y" regexp="y"/>
    
    <!-- Where command result capture -->
    <trigger name="qt_where_begin" match="^You search .+ for '.+'\.$" script="qt_where_begin" enabled="y" regexp="y"/>
    <trigger name="qt_where_line" match="^.+$" script="qt_where_line" enabled="n" regexp="y"/>
    <trigger name="qt_where_end" match="^$" script="qt_where_end" enabled="n" regexp="y"/>
    
    <!-- Auto oscan on stop running -->
    <trigger match="^You stop running\.$" script="qt_auto_scan" enabled="y" regexp="y"/>
    
    <!-- Unified scan trigger system - both scan and oscan use same triggers -->
    <trigger name="qt_unified_start" match="^Right here you see:$" script="qt_unified_begin" enabled="y" regexp="y" sequence="40"/>
    <trigger name="qt_unified_nearby" match="^\d+\s+\w+\s+you see:?\s*$" script="qt_unified_nearby_begin" enabled="y" regexp="y" sequence="40"/>
    <trigger name="qt_unified_line" match="^\s*-\s+(.+)$" script="qt_unified_line_handler" enabled="n" regexp="y" omit_from_output="y" sequence="40"/>
    <trigger name="qt_unified_end" match="^$" script="qt_unified_end_handler" enabled="n" regexp="y" sequence="40"/>
    <trigger name="qt_oscan_nothing" match="^You find nothing noteworthy while scanning the area\.$" script="qt_oscan_nothing_handler" enabled="y" regexp="y" omit_from_output="y" sequence="40"/>
    
    <!-- Home visit failure recovery -->
    <trigger match="^The Gods have forsaken you\.$" script="qt_gods_forsaken" enabled="y" regexp="y"/>
    <trigger match="^You are rooted in place!$" script="qt_rooted" enabled="y" regexp="y"/>
    <trigger match="^You pray for safe passage to a friend's home!$" script="qt_home_success" enabled="y" regexp="y"/>
    <trigger match="^There isn't a nexus bolted to the room\.$" script="qt_no_nexus" enabled="y" regexp="y"/>
    <trigger match="^You step through the nexus\.$" script="qt_nexus_success" enabled="y" regexp="y"/>
    <trigger match="^.+ grants you entry into .+'s home\.$" script="qt_home_granted" enabled="y" regexp="y"/>
    
    <!-- Clear pending_area when we see a room description -->
    <trigger match="^(.+): (.+) \(Id \d+\)\s*$" script="qt_room_arrived" enabled="y" regexp="y" sequence="100"/>
  </triggers>

  <script>
  <![CDATA[
-- Erion Quest Tracker v18.04 (Lua 5.1)
require "movewindow"

-- ===== State =====
local QT = { 
  debug=false, 
  rows={}, 
  exp_mode=false, 
  hots={}, 
  scroll_offset=0, 
  hover_row=nil, 
  quest_complete=false, 
  pending_area=nil, 
  auto_oscan=true,
  last_scan_time=0,
  scan_cooldown=2
}

-- ===== Quest Request Handlers =====
function qt_on_quest_request(name, line, wildcards)
  Note("[QT] Quest requested, sending quest info")
  QT.quest_complete = false
  Send("quest info")
end

function qt_on_junkyard_request(name, line, wildcards)
  Note("[QT] Junkyard quest requested - waiting for junkyard list")
  QT.quest_complete = false
end

function qt_on_expedition_request(name, line, wildcards)
  Note("[QT] Expedition requested - waiting for expedition output")
  QT.quest_complete = false
end

-- ===== Modern UI Theme =====
local UI = { 
  name="erion_qt_ui", 
  w=tonumber(GetVariable("qt_w") or "750"),
  h=tonumber(GetVariable("qt_h") or "280"), 
  
  bg=0x1a1a1a,
  bg_alt=0x202020,
  fg=0xe0e0e0,
  fg_dim=0xa0a0a0,
  
  primary=0xFFFF00,
  primary_hover=0xFFFF80,
  success=0x4ade80,
  warning=0xfbbf24,
  
  title_bg=0x2563eb,
  title_fg=0xffffff,
  header_bg=0x1e293b,
  header_fg=0xf1f5f9,
  border=0x334155,
  shadow=0x0f172a,
  
  font="Consolas", 
  fontsize=9,
  
  title_h=26, 
  header_h=24, 
  row_h=22, 
  status_h=22,
  visible=false,
  padding=12,
  gap=10,
  
  col_pct={10, 32, 28, 24, 6}
}

local function dprint(msg, ...) if QT.debug then if select("#", ...) > 0 then Note(string.format("[QT] "..msg, ...)) else Note("[QT] "..tostring(msg)) end end end
local function clamp_rows(max) while #QT.rows > max do table.remove(QT.rows,1) end end
local function add_row(t,a,r,m) table.insert(QT.rows,{type=t or "",area=a or "",room=r or "",mob=m or ""}); clamp_rows(500) end
local function clear_rows() QT.rows = {}; QT.scroll_offset = 0 end
local function ui_save_pos() SetVariable("qt_w", tostring(UI.w)); SetVariable("qt_h", tostring(UI.h)); movewindow.save_state(UI.name) end

local function clear_dynamic_hotspots() for id,_ in pairs(QT.hots) do WindowDeleteHotspot(UI.name, id) end QT.hots = {} end
local function add_hotspot(id,l,t,r,b,click_callback) 
  WindowAddHotspot(UI.name, id, l, t, r, b, "", "", "", "", click_callback, miniwin.cursor_hand or 0, 0)
  QT.hots[id]=true 
end

local function norm_lower(s) s=(s or ""):gsub("^%s+",""):gsub("%s+$",""); s=s:gsub("%s+"," "); return s:lower() end
local function strip_ansi(s) local ESC=string.char(27); return (s:gsub(ESC .. "%[[0-9;]*m","")) end

local function clean_capture(s)
  if not s then return "" end
  local ESC = string.char(27)
  s = s:gsub(ESC .. "%[[0-9;]*m", "")
  s = s:gsub("^%s+", ""):gsub("%s+$", "")
  s = s:gsub("%s+", " ")
  return s
end

local function fit_text(text, max_width, font_id)
  if not text or text == "" then return "" end
  local tw = WindowTextWidth(UI.name, font_id, text)
  if tw <= max_width then return text end
  
  local len = #text
  while len > 3 do
    local fitted = text:sub(1, len - 3) .. "..."
    if WindowTextWidth(UI.name, font_id, fitted) <= max_width then
      return fitted
    end
    len = len - 1
  end
  return "..."
end

local function click_area(area)
  area=norm_lower(area)
  if area=="" then return end
  
  dprint("click_area called: area='%s', pending_area='%s'", area, tostring(QT.pending_area))
  
  if QT.pending_area and QT.pending_area ~= area then
    dprint("Different area clicked, replacing pending_area")
    QT.pending_area = area
    Send("home visit kaeldrys")
    Send("nexus enter " .. area)
  elseif not QT.pending_area then
    QT.pending_area = area
    dprint("No pending_area, setting to: %s", area)
    Send("home visit kaeldrys")
    Send("nexus enter " .. area)
  else
    dprint("Same area '%s' clicked while pending, ignoring to prevent spam", area)
  end
end

local function click_room(room) room=norm_lower(room); if room=="" then return end; Execute("mapper find " .. room) end
local function click_mob(mob)  mob=norm_lower(mob); if mob==""  then return end; Send("where " .. mob) end
local function click_kill(mob) Send("kill @qt") end
local function click_get_quest() Send("get #quest") end

local windowinfo
local startx = 0
local starty = 0
local ui_draw

function qt_click_area(flags,id) 
  local i=tonumber(id:match("^qt_area_(%d+)$") or "")
  local r=QT.rows[i]
  if r and r.area and r.area ~= "" then click_area(r.area) end
end

function qt_click_room(flags,id) 
  local i=tonumber(id:match("^qt_room_(%d+)$") or "")
  local r=QT.rows[i]
  if r and r.room and r.room ~= "" then click_room(r.room) end
end

function qt_click_mob(flags,id)
  local i=tonumber(id:match("^qt_mob_(%d+)$") or "")
  local r=QT.rows[i]
  if r and r.mob and r.mob ~= "" then click_mob(r.mob) end
end

function qt_click_kill(flags,id)
  local i=tonumber(id:match("^qt_kill_(%d+)$") or "")
  local r=QT.rows[i]
  if r and r.mob and r.mob ~= "" then click_kill(r.mob) end
end

function qt_click_get(flags,id)
  local i=tonumber(id:match("^qt_get_(%d+)$") or "")
  local r=QT.rows[i]
  if r and (r.type == "Junkyard" or r.type == "GJunkyard") then click_get_quest() end
end

local function calc_columns(width)
  local pad = UI.padding
  local gap = UI.gap
  local inner = width - (pad * 2)
  local total_gap = gap * 4
  local available = inner - total_gap
  
  local type_w = math.floor(available * UI.col_pct[1] / 100)
  local area_w = math.floor(available * UI.col_pct[2] / 100)
  local room_w = math.floor(available * UI.col_pct[3] / 100)
  local mob_w = math.floor(available * UI.col_pct[4] / 100)
  local kill_w = available - type_w - area_w - room_w - mob_w
  
  return {
    type_x = pad, type_w = type_w,
    area_x = pad + type_w + gap, area_w = area_w,
    room_x = pad + type_w + gap + area_w + gap, room_w = room_w,
    mob_x = pad + type_w + gap + area_w + gap + room_w + gap, mob_w = mob_w,
    kill_x = pad + type_w + gap + area_w + gap + room_w + gap + mob_w + gap, kill_w = kill_w
  }
end

ui_draw = function()
  if not UI.visible then return end
  local w, h = UI.w, UI.h
  
  WindowRectOp(UI.name, miniwin.rect_fill, 0, 0, w, h, UI.bg)
  WindowGradient(UI.name, 0, 0, w, UI.title_h, UI.title_bg, 0x1e40af, 2)
  WindowText(UI.name, "qt_font_title", "Erion Quest Tracker", 13, 6, 0, 0, UI.title_fg)
  
  local cols = calc_columns(w)
  
  local hy1 = UI.title_h
  local hy2 = hy1 + UI.header_h
  WindowRectOp(UI.name, miniwin.rect_fill, 0, hy1, w, hy2, UI.header_bg)
  
  WindowText(UI.name, "qt_font_bold", "Type", cols.type_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  WindowText(UI.name, "qt_font_bold", "Area", cols.area_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  WindowText(UI.name, "qt_font_bold", "Room", cols.room_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  WindowText(UI.name, "qt_font_bold", "Target", cols.mob_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  WindowText(UI.name, "qt_font_bold", "Kill", cols.kill_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  
  WindowLine(UI.name, 0, hy2, w, hy2, UI.border, 0, 2)
  
  clear_dynamic_hotspots()
  
  local content_start = hy2 + 2
  local content_end = h - UI.status_h - 2
  local row_area_height = content_end - content_start
  local max_visible = math.floor(row_area_height / UI.row_h)
  local total_rows = #QT.rows
  
  if total_rows > max_visible then
    local scroll_x = w - 10
    local scroll_h = row_area_height - 8
    local scroll_y = content_start + 4
    
    WindowRectOp(UI.name, miniwin.rect_frame, scroll_x, scroll_y, scroll_x + 6, scroll_y + scroll_h, UI.border)
    
    local thumb_h = math.max(20, scroll_h * max_visible / total_rows)
    local thumb_y = scroll_y + (scroll_h - thumb_h) * QT.scroll_offset / math.max(1, total_rows - max_visible)
    WindowRectOp(UI.name, miniwin.rect_fill, scroll_x + 1, thumb_y, scroll_x + 5, thumb_y + thumb_h, UI.primary)
  end
  
  local start_idx = 1 + QT.scroll_offset
  local end_idx = math.min(total_rows, start_idx + max_visible - 1)
  
  local y = content_start
  for i = start_idx, end_idx do
    local r = QT.rows[i]
    if not r then break end
    
    local row_y = y
    
    if i % 2 == 1 then
      WindowRectOp(UI.name, miniwin.rect_fill, 0, row_y, w, row_y + UI.row_h, UI.bg_alt)
    end
    
    WindowLine(UI.name, UI.padding, row_y + UI.row_h - 1, w - UI.padding, row_y + UI.row_h - 1, UI.border, 0, 1)
    
    local text_y = row_y + 4
    
    local type_color = UI.fg_dim
    if r.type == "Quest" then type_color = UI.success
    elseif r.type == "Global" then type_color = UI.warning
    elseif r.type == "Expedition" then type_color = UI.primary end
    
    local type_text = fit_text(r.type, cols.type_w - 4, "qt_font")
    WindowText(UI.name, "qt_font_bold", type_text, cols.type_x + 2, text_y, 0, 0, type_color)
    
    local area_text = r.area or ""
    if area_text ~= "" then
      local fitted_area = fit_text(area_text, cols.area_w - 8, "qt_font")
      WindowText(UI.name, "qt_font", fitted_area, cols.area_x + 2, text_y, 0, 0, UI.primary)
      add_hotspot("qt_area_"..i, cols.area_x, row_y, cols.area_x + cols.area_w - 4, row_y + UI.row_h, "qt_click_area")
    end
    
    local room_text = r.room or ""
    if room_text ~= "" then
      local fitted_room = fit_text(room_text, cols.room_w - 8, "qt_font")
      WindowText(UI.name, "qt_font", fitted_room, cols.room_x + 2, text_y, 0, 0, UI.primary)
      add_hotspot("qt_room_"..i, cols.room_x, row_y, cols.room_x + cols.room_w - 4, row_y + UI.row_h, "qt_click_room")
    end
    
    local mob_text = r.mob or ""
    if mob_text ~= "" then
      local fitted_mob = fit_text(mob_text, cols.mob_w - 8, "qt_font")
      WindowText(UI.name, "qt_font", fitted_mob, cols.mob_x + 2, text_y, 0, 0, UI.primary)
      add_hotspot("qt_mob_"..i, cols.mob_x, row_y, cols.mob_x + cols.mob_w - 4, row_y + UI.row_h, "qt_click_mob")
      
      local btn_w = cols.kill_w - 4
      local btn_h = UI.row_h - 4
      local btn_x = cols.kill_x + 2
      local btn_y = row_y + 2
      
      local btn_text = "Kill"
      local btn_callback = "qt_click_kill"
      local btn_id = "qt_kill_"..i
      
      if r.type == "Junkyard" or r.type == "GJunkyard" then
        btn_text = "Get"
        btn_callback = "qt_click_get"
        btn_id = "qt_get_"..i
      end
      
      WindowRectOp(UI.name, miniwin.rect_fill, btn_x, btn_y, btn_x + btn_w, btn_y + btn_h, UI.primary)
      WindowRectOp(UI.name, miniwin.rect_frame, btn_x, btn_y, btn_x + btn_w, btn_y + btn_h, UI.border)
      
      local text_w = WindowTextWidth(UI.name, "qt_font_small", btn_text)
      local text_x = btn_x + (btn_w - text_w) / 2
      WindowText(UI.name, "qt_font_small", btn_text, text_x, btn_y + 4, 0, 0, UI.bg)
      
      add_hotspot(btn_id, btn_x, btn_y, btn_x + btn_w, btn_y + btn_h, btn_callback)
    end
    
    y = y + UI.row_h
    if y + UI.row_h > content_end then break end
  end
  
  local status_y = h - UI.status_h
  WindowRectOp(UI.name, miniwin.rect_fill, 0, status_y, w, h, UI.header_bg)
  WindowLine(UI.name, 0, status_y, w, status_y, UI.border, 0, 2)
  
  if total_rows > 0 then
    local count_text = string.format("%d quest%s", total_rows, total_rows ~= 1 and "s" or "")
    WindowText(UI.name, "qt_font_small", count_text, UI.padding, status_y + 6, 0, 0, UI.success)
  elseif QT.quest_complete then
    WindowText(UI.name, "qt_font_bold", "Return to Quest Giver and complete your task!", UI.padding, status_y + 4, 0, 0, 0x0000FF)
  else
    WindowText(UI.name, "qt_font_small", "No active quests", UI.padding, status_y + 6, 0, 0, UI.fg_dim)
  end
  
  for i = 1, 3 do
    local offset = i * 5
    WindowLine(UI.name, w - offset - 3, h - 4, w - 4, h - offset - 3, UI.border, 0, 2)
  end
end

local function ui_create()
  local POS=(miniwin and (miniwin.create_absolute_location or 0)) or 0
  windowinfo = movewindow.install(UI.name, miniwin.pos_top_right or 0, POS, true)
  WindowCreate(UI.name, windowinfo.window_left, windowinfo.window_top, UI.w, UI.h, windowinfo.window_mode or 0, windowinfo.window_flags or 0, UI.bg)
  
  WindowFont(UI.name, "qt_font", UI.font, UI.fontsize, false, false, false, false, 0, 0)
  WindowFont(UI.name, "qt_font_bold", UI.font, UI.fontsize, true, false, false, false, 0, 0)
  WindowFont(UI.name, "qt_font_title", UI.font, UI.fontsize + 1, true, false, false, false, 0, 0)
  WindowFont(UI.name, "qt_font_small", UI.font, UI.fontsize - 1, false, false, false, false, 0, 0)
  
  UI.visible=true
  WindowShow(UI.name, true)
  
  movewindow.add_drag_handler(UI.name, 0, 0, 0, UI.title_h)
  
  local resize_size = 20
  WindowAddHotspot(UI.name, "resize_handle",
                   UI.w - resize_size, UI.h - resize_size,
                   UI.w, UI.h,
                   "", "", "resize_start", "", "",
                   "Drag to resize",
                   miniwin.cursor_nw_se_arrow or 15, 0)
  WindowDragHandler(UI.name, "resize_handle", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
  
  ui_draw()
end

function ResizeMoveCallback()
  local posx = WindowInfo(UI.name, 17)
  local posy = WindowInfo(UI.name, 18)
  
  if not posx or not posy then return end
  if not UI.min_width then UI.min_width = 450 end
  if not UI.max_width then UI.max_width = 1400 end
  if not UI.min_height then UI.min_height = 180 end
  if not UI.max_height then UI.max_height = 900 end
  
  local new_w = math.max(UI.min_width, math.min(UI.max_width, UI.w + (posx - startx)))
  local new_h = math.max(UI.min_height, math.min(UI.max_height, UI.h + (posy - starty)))
  
  if new_w ~= UI.w or new_h ~= UI.h then
    UI.w = new_w
    UI.h = new_h
    startx = posx
    starty = posy
    WindowResize(UI.name, UI.w, UI.h, UI.bg)
    
    local resize_size = 20
    WindowMoveHotspot(UI.name, "resize_handle",
                     UI.w - resize_size, UI.h - resize_size,
                     UI.w, UI.h)
    
    if ui_draw then ui_draw() end
  end
end

function ResizeReleaseCallback()
  SetVariable("qt_w", tostring(UI.w))
  SetVariable("qt_h", tostring(UI.h))
  movewindow.save_state(UI.name)
end

function resize_start(flags, hotspot_id)
  startx = WindowInfo(UI.name, 17)
  starty = WindowInfo(UI.name, 18)
end

local function ui_show() if not UI.visible then ui_create() else WindowShow(UI.name,true); ui_draw() end end
local function ui_hide() if UI.visible then WindowShow(UI.name,false); WindowDelete(UI.name); UI.visible=false end end

-- ===== Known Area Names =====
local AREA_NAMES = {
  "Nokova Island", "Hillock Hills", "House of Lucius", "HoneyBee Village", "Tombstone Park",
  "The Forest of Ancient Guardians", "Monster Colosseum", "Embergreen", "Anglers Cove",
  "Roads to Allwhere Highway", "Hlua Orphanage", "Undersea Shipwrecks", "Primrose Plains Highway",
  "The Nomad Moors", "Underworld Den", "Divinity Pond", "Truel Village", "Distant Destinies Highway",
  "Crystal Creek", "The Rose Forest", "Crafters Forge", "Half-Moon Meadow", "Feyine", "Infested Mire",
  "Nadven Beach", "Crisscrossing Paths Highway", "Holy Grove", "Crow's Bay", "Palgrove Gallery",
  "Wayside Farm", "Snow Spire", "The Bandit Camp", "Kyeldor Zoo", "Tails Town", "Draconian Tower",
  "Everlasting Silence", "Tree of Pixies", "Rocky Roadways Highway", "Nexus of Nature",
  "Twilight Travels Highway", "Haven Lake", "Arachnos", "The Horizon Chaser", "Mahn-Tor",
  "Monster Park", "Carnival of Wonders", "Tiegre Town", "Nadven Shallows", "Centaur-Shaman Wars",
  "Mount Fulcrum", "Ivory Temple", "Alfrea", "Lurid", "Qualidesh", "Woodland Church",
  "Wildlife Reserve", "Oolrith Mountains", "Trails and Tales Highway", "Town of Bandell",
  "Abandoned Mines", "Old Reactor", "RiverRine", "Hilltop Trail Highway", "Dusk to Dawn",
  "Darnok's Citadel", "Arkham", "Glen Dhoo Forest", "The Roadhouse Inn", "Lierknay Forest",
  "Grim Deeps", "Orc Encampment", "Tree of Pixies II", "Rambling Roads Highway", "Cradlenook",
  "Cursed Manor", "High Tower of Sorcery", "Jungle of Xyzzyxx", "Timeless Trails Highway",
  "Cargan Ruins", "Mages Academy", "Avenue of the Ancients Highway", "Elvander", "Blackwater Canyon",
  "Fanatics' Tower", "Luminesea", "Drowshade", "UnderDark North", "Stone Forge", "Enchanted Falls",
  "Necroton Village and Cemetery", "Gauntlet of Death", "Besmirched Grounds",
  "Paths to Undecided Fates Highway", "UnderDark South", "Hobin's Haven", "City of Illyria",
  "Realms of Delusion", "Istyra Ocean", "Kriega", "Forgotten Fortress", "Emerald Forest",
  "Ironwood", "Illyrian Forest", "The Illyrian Tavern & Inn", "Fortune's Demise Highway",
  "Accursed Ruins", "Haluwah Island", "Drakyri Isle", "Valley of the Titans", "Tolchalla",
  "Emerald Way Highway", "Wayfarers Ridge Highway", "Field of Dreams Highway", "Land of the Lost Elves",
  "Realms of Enchantment", "Isle of the Dead", "Lankford Ruins", "Toy Factory", "SW Witch's Wood",
  "SE Witch's Wood", "NW Witch's Wood", "Divided Souls", "Kingshelm", "Stormy Straits Highway",
  "Nhe'Syri Village", "Chasm of Mayhem Highway", "NE Witch's Wood", "The Hollow", "Heaven's Command",
  "Hell", "Castle of Darkness", "The Gate", "The Highlands", "City of Tanaria", "Llothland",
  "Hadiran Monastery", "Winter Veil", "Paths to Ancient Legends Highway", "Witch's Mountain",
  "Kextra's Legendary Land of Myth", "Demon Eruption", "Nyxian Tunnels", "Artemisia Temple",
  "Jungle of Artemisia", "Umbral Sanctum", "The Horn Reborn", "Wyvern's Aerie", "Starlight Falls",
  "Demonweb Dominion", "Craftscape", "Freeze Tag Arena", "Merchants' Marketplace", "Chaos House Hall",
  "Newbies Tree House", "Hall of Doom", "Luminati House Hall", "Hall of Slayers", "Alchemy Academy",
  "Hall of Healers", "Sacellum's Holy House", "Red Light - Green Light", "Drunk Races",
  "Labyrinth Duo Quest", "Crimson Keep Party Quest"
}

local AREA_LOOKUP = {}
for _, area in ipairs(AREA_NAMES) do
  AREA_LOOKUP[area:lower()] = area
end

-- ===== PARSING PATTERNS =====
local Q_PAT = {
  giver_vicinity = ".-[Hh]unt%s+[Dd]own%s+(.+)%s+[Ii]n%s+[Tt]he%s+[Vv]icinity%s+[Oo]f%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  giver_simple   = ".-[Ff]ind%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  global_simple  = "^[Gg]lobal%s+[Qq]uest:.-%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  giver_spotted  = ".-[%!%?%.]%s+(.+)%s+[Hh]as%s+[Bb]een%s+[Ss]potted%s+[Ll]urking%s+[Nn]ear%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  giver_item     = ".-[Tt]hat%s+(.+?)'?s%s+[Nn]ow%s+[Ii]n%s+(.+)%s+[Ii]n%s+(.+?)%s*[,%.!]",
  giver_tracked  = ".-[Tt]he%s+(.+?)%s+[Hh]as%s+[Bb]een%s+[Tt]racked%s+[Tt]o%s+(.+)%s+[Ii]n%s+(.+?)%s*[,%.!]",
  junkyard_find  = ".-[Ff]ind%s+(.+)%s+[Ii]n%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  junkyard_quest = "^[Jj]unkyard%s+[Qq]uest:.-%s+(.+)%s+[Ii]n%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
}

local EXP_LINE_CAP = "^%s*Find%s+and%s+kill%s+(.+)%s+[Ii]n%s+([^%.%(]+)"

local function ui_update(t,a,r,m,opts) if opts and opts.clear then clear_rows() end add_row(t,a,r,m) if UI.visible then ui_draw() end end

local function qt_parse_line(line)
  dprint("IN: %s", line)
  line = clean_capture(line)
  
  local item2, rT, aT = string.match(line, Q_PAT.giver_tracked)
  if aT then 
    item2, rT, aT = clean_capture(item2), clean_capture(rT), clean_capture(aT)
    ui_update("Quest", aT, rT, item2, {clear=true})
    dprint("Quest tracked: item='%s' room='%s' area='%s'", item2, rT, aT)
    return 
  end
  
  local item, rI, aI = string.match(line, Q_PAT.giver_item)
  if aI then 
    item, rI, aI = clean_capture(item), clean_capture(rI), clean_capture(aI)
    ui_update("Quest", aI, rI, item, {clear=true})
    dprint("Quest item: item='%s' room='%s' area='%s'", item, rI, aI)
    return 
  end
  
  local mS, rS, aS = string.match(line, Q_PAT.giver_spotted)
  if aS then 
    mS, rS, aS = clean_capture(mS), clean_capture(rS), clean_capture(aS)
    ui_update("Quest", aS, rS, mS, {clear=true})
    dprint("Quest spotted: mob='%s' room='%s' area='%s'", mS, rS, aS)
    return 
  end
  
  local m1, r1, a1 = string.match(line, Q_PAT.giver_vicinity)
  if a1 then 
    m1, r1, a1 = clean_capture(m1), clean_capture(r1), clean_capture(a1)
    ui_update("Quest", a1, r1, m1, {clear=true})
    dprint("Quest vicinity: mob='%s' room='%s' area='%s'", m1, r1, a1)
    return 
  end
  
  local itemJ, roomJ, areaJ = string.match(line, Q_PAT.junkyard_find)
  if areaJ then 
    itemJ, roomJ, areaJ = clean_capture(itemJ), clean_capture(roomJ), clean_capture(areaJ)
    ui_update("Junkyard", areaJ, roomJ, itemJ, {clear=true})
    dprint("Junkyard quest: item='%s' room='%s' area='%s'", itemJ, roomJ, areaJ)
    return 
  end
  
  local itemJQ, roomJQ, areaJQ = string.match(line, Q_PAT.junkyard_quest)
  if areaJQ then 
    itemJQ, roomJQ, areaJQ = clean_capture(itemJQ), clean_capture(roomJQ), clean_capture(areaJQ)
    ui_update("Junkyard", areaJQ, roomJQ, itemJQ, {clear=true})
    dprint("Junkyard Quest line: item='%s' room='%s' area='%s'", itemJQ, roomJQ, areaJQ)
    return 
  end
  
  local m2, a2 = string.match(line, Q_PAT.giver_simple)
  if a2 then 
    m2, a2 = clean_capture(m2), clean_capture(a2)
    ui_update("Quest", a2, "", m2, {clear=true})
    dprint("Quest simple: mob='%s' area='%s'", m2, a2)
    return 
  end
  
  local gmob, garea = string.match(line, Q_PAT.global_simple)
  if garea then 
    gmob, garea = clean_capture(gmob), clean_capture(garea)
    ui_update("Global", garea, "", gmob, {clear=false})
    dprint("Global line: mob='%s' area='%s'", gmob, garea)
    return 
  end
  
  dprint("No quest pattern matched.")
end

function qt_parse_quest(name, line, wildcards) qt_parse_line(line or "") end

local QUEST_STATE = { skip_quest_info = false }

function qt_parse_quest_giver(name, line, wildcards)
  local giver_text = line or ""
  
  dprint("Giver line received: %s", giver_text)
  
  if giver_text:match("[Cc]ongratulations") or giver_text:match("[Ww]ell done") or giver_text:match("[Tt]hank you") or
     giver_text:match("experience points") or giver_text:match("gold coins") or giver_text:match("quest points") then
    dprint("Detected quest completion - skipping")
    return
  end
  
  if giver_text:match("minutes? left to gather") then
    dprint("Detected timed junkyard quest - skipping quest info")
    QUEST_STATE.skip_quest_info = true
    return
  end
  
  if giver_text:match("[Ee]xpedition") then
    dprint("Detected expedition quest - skipping quest info")
    QUEST_STATE.skip_quest_info = true
    return
  end
  
  if not (giver_text:match("[Qq]uest") or giver_text:match("[Ff]ind") or giver_text:match("[Kk]ill") or 
          giver_text:match("[Hh]unt") or giver_text:match("[Ss]lay")) then
    dprint("Giver speaking but not giving a quest - skipping")
    return
  end
  
  dprint("Giver detected regular quest - parsing line and requesting quest info")
  QUEST_STATE.skip_quest_info = false
  
  qt_parse_line(giver_text)
  Send("quest info")
end

function qt_gag_no_quest(name, line, wildcards) dprint("Gagged 'not on quest' message") end

function qt_parse_quest_info(name, line, wildcards)
  local room, area
  line = strip_ansi(line or "")
  
  dprint("Quest info line: %s", line)
  
  local quest_part = line:match("^You are on a quest to %w+ (.+)$")
  if not quest_part then
    dprint("Failed to extract quest part")
    return
  end
  
  quest_part = quest_part:gsub("%.$", "")
  dprint("Quest part: %s", quest_part)
  
  local has_vicinity = quest_part:match("in the vicinity of")
  
  if has_vicinity then
    local after_vicinity = quest_part:match("in the vicinity of (.+)$")
    if not after_vicinity then
      dprint("Failed to extract after vicinity")
      return
    end
    
    dprint("After vicinity: %s", after_vicinity)
    
    local separators = {}
    local search_pos = 1
    while true do
      local of_pos = after_vicinity:lower():find(" of ", search_pos, true)
      local in_pos = after_vicinity:lower():find(" in ", search_pos, true)
      
      local next_pos = nil
      local next_type = nil
      local next_len = 0
      
      if of_pos and in_pos then
        if of_pos < in_pos then
          next_pos = of_pos
          next_type = " of "
          next_len = 4
        else
          next_pos = in_pos
          next_type = " in "
          next_len = 4
        end
      elseif of_pos then
        next_pos = of_pos
        next_type = " of "
        next_len = 4
      elseif in_pos then
        next_pos = in_pos
        next_type = " in "
        next_len = 4
      end
      
      if next_pos then
        table.insert(separators, {pos = next_pos, type = next_type, len = next_len})
        search_pos = next_pos + 1
      else
        break
      end
    end
    
    dprint("Found %d separators", #separators)
    
    if #separators > 0 then
      local best_match = nil
      for i = 1, #separators do
        local sep = separators[i]
        local potential_area = after_vicinity:sub(sep.pos + sep.len)
        local area_lower = potential_area:lower()
        
        if AREA_LOOKUP[area_lower] then
          dprint("Found area match: '%s' at separator %d", potential_area, i)
          best_match = i
          break
        end
      end
      
      if best_match then
        local matched_sep = separators[best_match]
        room = after_vicinity:sub(1, matched_sep.pos - 1)
        area = after_vicinity:sub(matched_sep.pos + matched_sep.len)
        dprint("Using matched separator at pos %d: room='%s' area='%s'", matched_sep.pos, room, area)
      else
        dprint("No area name match found, using last separator")
        local last_sep = separators[#separators]
        room = after_vicinity:sub(1, last_sep.pos - 1)
        area = after_vicinity:sub(last_sep.pos + last_sep.len)
        dprint("Using last separator at pos %d: room='%s' area='%s'", last_sep.pos, room, area)
      end
    else
      dprint("No separators found in vicinity format")
      return
    end
  else
    local after_in = quest_part:match("in (.+)$")
    if not after_in then
      dprint("Failed to extract after 'in'")
      return
    end
    
    dprint("After in: %s", after_in)
    
    local separators = {}
    local search_pos = 1
    while true do
      local of_pos = after_in:lower():find(" of ", search_pos, true)
      local in_pos = after_in:lower():find(" in ", search_pos, true)
      
      local next_pos = nil
      local next_type = nil
      local next_len = 0
      
      if of_pos and in_pos then
        if of_pos < in_pos then
          next_pos = of_pos
          next_type = " of "
          next_len = 4
        else
          next_pos = in_pos
          next_type = " in "
          next_len = 4
        end
      elseif of_pos then
        next_pos = of_pos
        next_type = " of "
        next_len = 4
      elseif in_pos then
        next_pos = in_pos
        next_type = " in "
        next_len = 4
      end
      
      if next_pos then
        table.insert(separators, {pos = next_pos, type = next_type, len = next_len})
        search_pos = next_pos + 1
      else
        break
      end
    end
    
    dprint("Found %d separators", #separators)
    
    if #separators > 0 then
      local best_match = nil
      for i = 1, #separators do
        local sep = separators[i]
        local potential_area = after_in:sub(sep.pos + sep.len)
        local area_lower = potential_area:lower()
        
        if AREA_LOOKUP[area_lower] then
          dprint("Found area match: '%s' at separator %d", potential_area, i)
          best_match = i
          break
        end
      end
      
      if best_match then
        local matched_sep = separators[best_match]
        room = after_in:sub(1, matched_sep.pos - 1)
        area = after_in:sub(matched_sep.pos + matched_sep.len)
        dprint("Using matched separator at pos %d: room='%s' area='%s'", matched_sep.pos, room, area)
      else
        dprint("No area name match found, using last separator")
        local last_sep = separators[#separators]
        room = after_in:sub(1, last_sep.pos - 1)
        area = after_in:sub(last_sep.pos + last_sep.len)
        dprint("Using last separator at pos %d: room='%s' area='%s'", last_sep.pos, room, area)
      end
    else
      dprint("No separators found in simple format")
      return
    end
  end
  
  if area and room then
    local target = line:match("^You are on a quest to %w+ (.+) in the vicinity of") or 
                   line:match("^You are on a quest to %w+ (.+) in") or 
                   "target"
    target, room, area = clean_capture(target), clean_capture(room), clean_capture(area)
    ui_update("Quest", area, room, target, {clear=true})
    dprint("Quest info captured: target='%s' room='%s' area='%s'", target, room, area)
  else
    dprint("Failed to parse quest info - room='%s' area='%s'", tostring(room), tostring(area))
  end
end

-- Expeditions
function qt_exp_begin(name, line, wildcards) QT.exp_mode = true; clear_rows(); dprint("Expedition START") end
function qt_exp_line(name, line, wildcards)
  if not QT.exp_mode then return end
  line = strip_ansi(line or "")
  dprint("Expedition line: '%s'", line)
  
  local mob, area = string.match(line, EXP_LINE_CAP)
  if mob and area then
    area, mob = clean_capture(area), clean_capture(mob)
    ui_update("Expedition", area, "", mob, {clear=false})
    dprint("Expedition target captured: mob='%s' area='%s'", mob, area)
  else
    dprint("Expedition line did not match pattern")
  end
end
function qt_exp_end(name, line, wildcards) if QT.exp_mode then QT.exp_mode = false; dprint("Expedition END") end end

-- ===== Global Junkyards =====
local GJY = { active=false, buf="", expecting_cont=false }
local function _qt_gjy_enable_line(on) EnableTrigger("qt_gjy_line", on and true or false) end
local function _qt_gjy_enable_cont(on) EnableTrigger("qt_gjy_cont", on and true or false) end
local function _qt_collapse2(s) return (s or ""):gsub("[%s\r\n]+", " "):gsub("^%s+",""):gsub("%s+$","") end

local function _qt_gjy_try_parse()
  if not GJY.buf or GJY.buf == "" then return false end
  local s = _qt_collapse2(GJY.buf)
  
  dprint("GJY trying to parse: '%s'", s)
  
  local without_num = s:match("^%d+%.%s+(.+)$")
  if not without_num then
    dprint("GJY: Could not strip number prefix")
    return false
  end
  
  without_num = without_num:gsub("%s*%([Hh][Ee][Rr][Ee]%)%s*", " ")
  without_num = without_num:gsub("%.%s*$", "")
  without_num = without_num:gsub("%s+$", "")
  
  local positions = {}
  local search_pos = 1
  while true do
    local found_pos = without_num:lower():find(" in ", search_pos, true)
    if not found_pos then break end
    table.insert(positions, found_pos)
    search_pos = found_pos + 1
  end
  
  if #positions < 2 then
    dprint("GJY: Need at least 2 ' in ' separators, found %d", #positions)
    return false
  end
  
  dprint("GJY: Found %d ' in ' separators", #positions)
  
  local best_match = nil
  for i = 2, #positions do
    local potential_area = without_num:sub(positions[i] + 4)
    local area_lower = potential_area:lower()
    
    if AREA_LOOKUP[area_lower] then
      dprint("GJY: Found area match '%s' at separator %d", potential_area, i)
      best_match = i
      break
    end
  end
  
  local item_separator, area_separator
  if best_match then
    item_separator = positions[1]
    area_separator = positions[best_match]
    dprint("GJY: Using area match at position %d", best_match)
  else
    dprint("GJY: No area match, using first and last separators")
    item_separator = positions[1]
    area_separator = positions[#positions]
  end
  
  local item = without_num:sub(1, item_separator - 1)
  local room = without_num:sub(item_separator + 4, area_separator - 1)
  local area = without_num:sub(area_separator + 4)
  
  if item and room and area then
    item, room, area = clean_capture(item), clean_capture(room), clean_capture(area)
    dprint("GJY parsed: item='%s' room='%s' area='%s'", item, room, area)
    if ui_update then ui_update("GJunkyard", area, room, item, {clear=false}) end
    GJY.buf, GJY.expecting_cont = "", false
    _qt_gjy_enable_cont(false)
    _qt_gjy_enable_line(true)
    return true
  end
  
  dprint("GJY parse failed")
  return false
end

function qt_gjy_begin(name, line, wildcards)
  GJY.active, GJY.buf, GJY.expecting_cont = true, "", false
  _qt_gjy_enable_line(true)
  _qt_gjy_enable_cont(false)
  if clear_rows then clear_rows() end
  dprint("Global Junkyard BEGIN")
end

function qt_gjy_line(name, line, wildcards)
  if not GJY.active then return end
  dprint("GJY line: '%s'", line)
  
  if GJY.buf ~= "" and line:match("^%s*%d+%.") then
    dprint("New item detected, parsing previous buffer first")
    _qt_gjy_try_parse()
  end
  
  GJY.buf = (GJY.buf == "" and line or (GJY.buf .. " " .. line))
  GJY.expecting_cont = true
  _qt_gjy_enable_cont(true)
  _qt_gjy_enable_line(true)
  _qt_gjy_try_parse()
end

function qt_gjy_cont(name, line, wildcards)
  if not (GJY.active and GJY.expecting_cont) then return end
  
  dprint("GJY cont: '%s'", line)
  
  if line:match("^%s*-+%s*$") or line:match("^%s*$") then
    dprint("GJY end marker detected")
    if GJY.buf ~= "" then
      _qt_gjy_try_parse()
    end
    GJY.active, GJY.buf, GJY.expecting_cont = false, "", false
    _qt_gjy_enable_line(false)
    _qt_gjy_enable_cont(false)
    return
  end
  
  if line:match("^%s*%d+%.") then
    dprint("New item number detected, parsing previous buffer")
    _qt_gjy_try_parse()
    GJY.buf = line
    _qt_gjy_try_parse()
  else
    GJY.buf = (GJY.buf == "" and line or (GJY.buf .. " " .. line))
    _qt_gjy_try_parse()
  end
end

-- ===== Timed Junkyard Quest =====
local JY = { active=false, buf="", expecting_cont=false }
local function _qt_jy_enable_line(on) EnableTrigger("qt_jy_line", on and true or false) end
local function _qt_jy_enable_cont(on) EnableTrigger("qt_jy_cont", on and true or false) end
local function _qt_jy_enable_end(on) EnableTrigger("qt_jy_end", on and true or false) end

local function _qt_jy_try_parse()
  if not JY.buf or JY.buf == "" then return false end
  local s = _qt_collapse2(JY.buf)
  
  dprint("JY trying to parse: '%s'", s)
  
  local without_num = s:match("^%[%s*%d+%s*%]%s+(.+)$")
  if not without_num then
    dprint("JY: Could not strip bracket prefix")
    return false
  end
  
  without_num = without_num:gsub("%s*%([Hh][Ee][Rr][Ee]%)%s*", " ")
  without_num = without_num:gsub("%.%s*$", "")
  without_num = without_num:gsub("%s+$", "")
  
  local positions = {}
  local search_pos = 1
  while true do
    local found_pos = without_num:lower():find(" in ", search_pos, true)
    if not found_pos then break end
    table.insert(positions, found_pos)
    search_pos = found_pos + 1
  end
  
  if #positions < 2 then
    dprint("JY: Need at least 2 ' in ' separators, found %d", #positions)
    return false
  end
  
  dprint("JY: Found %d ' in ' separators", #positions)
  
  local best_match = nil
  for i = 2, #positions do
    local potential_area = without_num:sub(positions[i] + 4)
    local area_lower = potential_area:lower()
    
    if AREA_LOOKUP[area_lower] then
      dprint("JY: Found area match '%s' at separator %d", potential_area, i)
      best_match = i
      break
    end
  end
  
  local item_separator, area_separator
  if best_match then
    item_separator = positions[1]
    area_separator = positions[best_match]
    dprint("JY: Using area match at position %d", best_match)
  else
    dprint("JY: No area match, using first and last separators")
    item_separator = positions[1]
    area_separator = positions[#positions]
  end
  
  local item = without_num:sub(1, item_separator - 1)
  local room = without_num:sub(item_separator + 4, area_separator - 1)
  local area = without_num:sub(area_separator + 4)
  
  if item and room and area then
    item, room, area = clean_capture(item), clean_capture(room), clean_capture(area)
    dprint("JY parsed successfully: item='%s' room='%s' area='%s'", item, room, area)
    ui_update("Junkyard", area, room, item, {clear=false})
    JY.buf, JY.expecting_cont = "", false
    _qt_jy_enable_cont(false)
    _qt_jy_enable_line(true)
    return true
  end
  
  dprint("JY parse failed - may need continuation")
  return false
end

function qt_jy_begin(name, line, wildcards)
  JY.active, JY.buf, JY.expecting_cont = true, "", false
  _qt_jy_enable_line(true)
  _qt_jy_enable_cont(false)
  _qt_jy_enable_end(true)
  clear_rows()
  dprint("Timed Junkyard Quest START")
end

function qt_jy_line(name, line, wildcards)
  if not JY.active then return end
  dprint("JY line received: '%s'", line)
  
  if JY.buf ~= "" and line:match("^%s*%[%s*%d+%s*%]") then
    dprint("New item detected, parsing previous buffer first")
    _qt_jy_try_parse()
  end
  
  JY.buf = (JY.buf == "" and line or (JY.buf .. " " .. line))
  JY.expecting_cont = true
  _qt_jy_enable_cont(true)
  _qt_jy_enable_line(true)
  _qt_jy_try_parse()
end

function qt_jy_cont(name, line, wildcards)
  if not (JY.active and JY.expecting_cont) then return end
  
  dprint("JY cont received: '%s'", line)
  
  if line:match("^%s*$") then
    dprint("JY blank line - ending")
    if JY.buf ~= "" then
      _qt_jy_try_parse()
    end
    JY.active, JY.buf, JY.expecting_cont = false, "", false
    _qt_jy_enable_line(false)
    _qt_jy_enable_cont(false)
    _qt_jy_enable_end(false)
    return
  end
  
  if line:match("^%s*%[%s*%d+%s*%]") then
    dprint("New bracketed item in continuation, parsing previous first")
    _qt_jy_try_parse()
    JY.buf = line
    _qt_jy_try_parse()
  else
    JY.buf = (JY.buf == "" and line or (JY.buf .. " " .. line))
    _qt_jy_try_parse()
  end
end

function qt_jy_end(name, line, wildcards)
  if JY.active then
    dprint("JY end trigger: '%s'", line)
    
    if JY.buf ~= "" then
      dprint("Parsing remaining buffer before end")
      _qt_jy_try_parse()
    end
    
    JY.active, JY.buf, JY.expecting_cont = false, "", false
    _qt_jy_enable_line(false)
    _qt_jy_enable_cont(false)
    _qt_jy_enable_end(false)
    dprint("Timed Junkyard Quest END")
  end
end

-- ===== Global Quest targets =====
local GQ = { active=false }
local function _qt_gq_enable_line(on) EnableTrigger("qt_gq_line", on and true or false) end
local function _qt_gq_enable_end(on) EnableTrigger("qt_gq_end", on and true or false) end

function qt_gq_begin(name, line, wildcards)
  GQ.active = true
  _qt_gq_enable_line(true)
  _qt_gq_enable_end(true)
  clear_rows()
  dprint("Global Quest targets START")
end

function qt_gq_line(name, line, wildcards)
  if not GQ.active then return end
  line = strip_ansi(line or "")
  
  dprint("GQ Line raw: '%s'", line)
  
  if line:match("^%s*%d+%.%s*%?+%s*$") then
    dprint("Skipping placeholder line: %s", line)
    return
  end
  
  local without_num = line:match("^%s*%d+%.%s+(.+)$")
  if not without_num then
    dprint("GQ: Could not strip number prefix")
    return
  end
  
  without_num = without_num:gsub("%.%s*$", "")
  without_num = without_num:gsub("%s+$", "")
  
  dprint("GQ without number: '%s'", without_num)
  
  local positions = {}
  local search_pos = 1
  while true do
    local found_pos = without_num:lower():find(" in ", search_pos, true)
    if not found_pos then break end
    table.insert(positions, found_pos)
    search_pos = found_pos + 1
  end
  
  dprint("GQ: Found %d ' in ' separators", #positions)
  
  if #positions == 0 then
    dprint("GQ: No ' in ' separator found")
    return
  elseif #positions == 1 then
    local mob = without_num:sub(1, positions[1] - 1)
    local area = without_num:sub(positions[1] + 4)
    
    mob, area = clean_capture(mob), clean_capture(area)
    
    if AREA_LOOKUP[area:lower()] then
      dprint("GQ: Simple format matched - mob='%s' area='%s'", mob, area)
      ui_update("Global", area, "", mob, {clear=false})
      return
    else
      dprint("GQ: Area '%s' not in lookup", area)
      return
    end
  else
    local best_match = nil
    for i = 1, #positions do
      local potential_area = without_num:sub(positions[i] + 4)
      local area_lower = potential_area:lower()
      
      if AREA_LOOKUP[area_lower] then
        dprint("GQ: Found area match '%s' at separator %d", potential_area, i)
        best_match = i
        break
      end
    end
    
    if best_match then
      if best_match == 1 then
        local mob = without_num:sub(1, positions[1] - 1)
        local area = without_num:sub(positions[1] + 4)
        mob, area = clean_capture(mob), clean_capture(area)
        dprint("GQ: mob='%s' room='' area='%s'", mob, area)
        ui_update("Global", area, "", mob, {clear=false})
      else
        local mob = without_num:sub(1, positions[1] - 1)
        local room = without_num:sub(positions[1] + 4, positions[best_match] - 1)
        local area = without_num:sub(positions[best_match] + 4)
        mob, room, area = clean_capture(mob), clean_capture(room), clean_capture(area)
        dprint("GQ: mob='%s' room='%s' area='%s'", mob, room, area)
        ui_update("Global", area, room, mob, {clear=false})
      end
    else
      dprint("GQ: No area match, using last separator")
      local last_pos = positions[#positions]
      local mob_and_maybe_room = without_num:sub(1, last_pos - 1)
      local area = without_num:sub(last_pos + 4)
      
      if #positions > 1 then
        local mob = without_num:sub(1, positions[1] - 1)
        local room = without_num:sub(positions[1] + 4, last_pos - 1)
        mob, room, area = clean_capture(mob), clean_capture(room), clean_capture(area)
        dprint("GQ: (fallback with room) mob='%s' room='%s' area='%s'", mob, room, area)
        ui_update("Global", area, room, mob, {clear=false})
      else
        local mob = mob_and_maybe_room
        mob, area = clean_capture(mob), clean_capture(area)
        dprint("GQ: (fallback no room) mob='%s' area='%s'", mob, area)
        ui_update("Global", area, "", mob, {clear=false})
      end
    end
  end
end

function qt_gq_end(name, line, wildcards)
  if GQ.active then
    GQ.active = false
    _qt_gq_enable_line(false)
    _qt_gq_enable_end(false)
    dprint("Global Quest targets END")
  end
end

-- ===== Death removal =====
local function remove_row_by_mob(mobline)
  if not mobline or mobline == "" then return false end
  local key = norm_lower(strip_ansi(mobline))
  
  for i=1,#QT.rows do
    local r = QT.rows[i]
    if r and norm_lower(r.mob or "") == key then
      table.remove(QT.rows, i)
      
      if #QT.rows == 0 then
        QT.quest_complete = true
        dprint("Last quest target killed - quest complete!")
      end
      
      ui_draw()
      dprint("Removed row (exact match) for death: %s", mobline)
      return true
    end
  end
  
  for i=1,#QT.rows do
    local r = QT.rows[i]
    local mob_normalized = norm_lower(r.mob or "")
    if mob_normalized ~= "" and mob_normalized:find(key, 1, true) then
      table.remove(QT.rows, i)
      
      if #QT.rows == 0 then
        QT.quest_complete = true
        dprint("Last quest target killed - quest complete!")
      end
      
      ui_draw()
      dprint("Removed row (partial match) for death: %s matched %s", mobline, r.mob)
      return true
    end
  end
  
  return false
end

function qt_on_death(name, line, wildcards)
  local raw = line or ""
  local mob = raw:match("^%s*(.+)%s+is%s+dead!")
  if mob then
    if not remove_row_by_mob(mob) then
      dprint("Death seen but no matching row: %s", mob)
    end
  end
end

-- ===== Quest Turn-in =====
function qt_on_quest_turnin(name, line, wildcards)
  dprint("Quest turned in")
  QT.quest_complete = false
  clear_rows()
  ui_draw()
end

-- ===== Item pickup removal =====
local function remove_row_by_item(itemline)
  if not itemline or itemline == "" then return false end
  local key = norm_lower(strip_ansi(itemline))
  
  dprint("Item pickup: looking for '%s'", key)
  
  for i=1,#QT.rows do
    local r = QT.rows[i]
    local row_item = norm_lower(r.mob or "")
    dprint("  Comparing with row %d: '%s'", i, row_item)
    
    if row_item == key then
      table.remove(QT.rows, i)
      
      if #QT.rows == 0 then
        QT.quest_complete = true
        dprint("Last junkyard item collected - quest complete!")
      end
      
      ui_draw()
      dprint("Removed row (exact match) for item pickup: %s", itemline)
      return true
    end
  end
  
  for i=1,#QT.rows do
    local r = QT.rows[i]
    local item_normalized = norm_lower(r.mob or "")
    
    if item_normalized ~= "" then
      if item_normalized:find(key, 1, true) or key:find(item_normalized, 1, true) then
        table.remove(QT.rows, i)
        
        if #QT.rows == 0 then
          QT.quest_complete = true
          dprint("Last junkyard item collected - quest complete!")
        end
        
        ui_draw()
        dprint("Removed row (partial match) for item pickup: '%s' matched '%s'", itemline, r.mob)
        return true
      end
    end
  end
  
  dprint("No matching item found in tracker for: %s", itemline)
  return false
end

function qt_on_item_pickup(name, line, wildcards)
  local item = wildcards[1] or ""
  if item ~= "" then
    dprint("Item pickup trigger fired: %s", item)
    if not remove_row_by_item(item) then
      dprint("Item pickup seen but no matching row: %s", item)
    end
  end
end

-- ===== Lifecycle =====
function OnPluginInstall() ui_show() end
function OnPluginEnable()  ui_show() end
function OnPluginDisable() ui_hide() end
function OnPluginSaveState() ui_save_pos() end

-- ===== Commands =====
local function echo(s) Note("[QT] "..s) end

local function show_help()
  ColourNote("cyan", "", string.rep("=", 76))
  ColourNote("white", "", "                    Erion Quest Tracker v18.04")
  ColourNote("cyan", "", string.rep("=", 76))
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "COMMANDS:")
  ColourNote("lime", "", "  qt on/off         ", "white", "", "- Show/hide tracker window")
  ColourNote("lime", "", "  qt clear          ", "white", "", "- Clear all tracked quests")
  ColourNote("lime", "", "  qt reset          ", "white", "", "- Reset window size and position")
  ColourNote("lime", "", "  qt oscan on|off   ", "white", "", "- Toggle auto scan on stop running")
  ColourNote("lime", "", "  qt cooldown <0-10>", "white", "", "- Set scan cooldown (default: 2 sec)")
  ColourNote("lime", "", "  qt debug on|off   ", "white", "", "- Toggle debug output")
  ColourNote("lime", "", "  qt help           ", "white", "", "- Show this help")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "USAGE:")
  ColourNote("white", "", "  Request quests normally:")
  ColourNote("lime", "", "    quest request", "white", "", "  |  ", "lime", "", "quest junkyard", "white", "", "  |  ", "lime", "", "quest expedition")
  ColourNote("white", "", "")
  ColourNote("white", "", "  Click to navigate:")
  ColourNote("cyan", "", "    Area   ", "white", "", "- Teleport to nexus entrance")
  ColourNote("cyan", "", "    Room   ", "white", "", "- Find with mapper")
  ColourNote("cyan", "", "    Target ", "white", "", "- Locate with 'where' command")
  ColourNote("cyan", "", "    [Kill] ", "white", "", "- Attack mob (sends 'kill @qt')")
  ColourNote("cyan", "", "    [Get]  ", "white", "", "- Collect item (sends 'get #quest')")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "AUTO-REMOVAL:")
  ColourNote("white", "", "  Quest mobs removed when killed, junkyard items when picked up")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "AUTO-SCAN:")
  ColourNote("white", "", "  Automatically scans on stop running (cooldown prevents spam)")
  ColourNote("white", "", "  • Quest mobs: 'scan @qt' → highlights with [Q]/[GQ]/[EXP]")
  ColourNote("white", "", "  • Junkyard items: 'oscan #quest' → highlights with [JY]/[GJY]")
  ColourNote("cyan", "", string.rep("=", 76))
end

function qt_cmd(args)
  local a={} for t in string.gmatch(args or "", "[^%s]+") do table.insert(a,t) end
  local sub=(a[1] or ""):lower()
  if sub=="on" then ui_show(); echo("UI: shown")
  elseif sub=="off" then ui_hide(); echo("UI: hidden")
  elseif sub=="reset" then UI.w,UI.h=750,280; ui_show(); ui_save_pos(); echo("UI: reset")
  elseif sub=="clear" then clear_rows(); ui_draw(); echo("Rows cleared")
  elseif sub=="oscan" then
    local oscan_arg = (a[2] or ""):lower()
    if oscan_arg == "on" or oscan_arg == "1" then
      QT.auto_oscan = true
      echo("Auto oscan: ON")
    elseif oscan_arg == "off" or oscan_arg == "0" then
      QT.auto_oscan = false
      echo("Auto oscan: OFF")
    else
      QT.auto_oscan = not QT.auto_oscan
      echo("Auto oscan: " .. (QT.auto_oscan and "ON" or "OFF"))
    end
  elseif sub=="cooldown" then
    local cooldown_val = tonumber(a[2])
    if cooldown_val and cooldown_val >= 0 and cooldown_val <= 10 then
      QT.scan_cooldown = cooldown_val
      echo(string.format("Scan cooldown: %d seconds", cooldown_val))
    else
      echo(string.format("Current cooldown: %d seconds (use: qt cooldown <0-10>)", QT.scan_cooldown))
    end
  elseif sub=="debug" then 
    local debug_arg = (a[2] or ""):lower()
    if debug_arg == "on" or debug_arg == "1" then
      QT.debug = true
      echo("Debug: ON")
    elseif debug_arg == "off" or debug_arg == "0" then
      QT.debug = false
      echo("Debug: OFF")
    else
      QT.debug = not QT.debug
      echo("Debug: " .. (QT.debug and "ON" or "OFF"))
    end
  elseif sub=="help" or sub=="?" then show_help()
  else
    echo("Commands: on|off|clear|reset|oscan|cooldown|debug|help")
    echo("Type 'qt help' for full documentation")
  end
end

-- ===== Global Quest Win =====
function qt_global_win(name, line, wildcards)
  dprint("Global quest win detected")
  for i=#QT.rows,1,-1 do
    local r = QT.rows[i]
    if r and r.type == "Global" then
      table.remove(QT.rows, i)
      dprint("Removed Global quest row: %s", r.mob or "")
    end
  end
  QT.quest_complete = false
  if UI and UI.visible then 
    ui_draw() 
  end
  dprint("Global quest completed - cleared all Global rows and reset status")
end

-- ===== Gods Forsaken Recovery =====
function qt_gods_forsaken(name, line, wildcards)
  dprint("Gods have forsaken - attempting recovery")
  if QT.pending_area and QT.pending_area ~= "" then
    local area = QT.pending_area
    Note("[QT] Attempting to recover home visit via hag entrance...")
    Send("enter hag")
    Send("home visit kaeldrys")
    Send("nexus enter " .. area)
    dprint("Recovery sequence sent for area: %s", area)
  else
    dprint("No pending area to retry")
  end
end

function qt_rooted(name, line, wildcards)
  dprint("Rooted in place - clearing pending area")
  if QT.pending_area then
    Note("[QT] Cannot travel while rooted. Clear root and try again.")
    QT.pending_area = nil
  end
end

function qt_home_success(name, line, wildcards)
  dprint("Home visit prayer detected - waiting for grant or forsaken")
end

function qt_home_granted(name, line, wildcards)
  dprint("Home visit granted - nexus command should execute next")
end

function qt_no_nexus(name, line, wildcards)
  dprint("No nexus in room - clearing pending area")
  if QT.pending_area then
    Note("[QT] No nexus found. Navigation halted.")
    QT.pending_area = nil
  end
end

function qt_nexus_success(name, line, wildcards)
  if QT.pending_area then
    dprint("Successfully entered nexus for area: %s - CLEARING pending_area", QT.pending_area)
    QT.pending_area = nil
  else
    dprint("Entered nexus but no pending_area was set")
  end
end

function qt_room_arrived(name, line, wildcards)
  if QT.pending_area then
    local area_name = wildcards[1] or ""
    dprint("Arrived at room in '%s' - CLEARING pending_area (was: %s)", area_name, QT.pending_area)
    QT.pending_area = nil
  end
end

-- ===== Scan/Oscan State Management =====
local OSCAN = { active=false, location="", waiting_for_items=false, found_items=false }
local SCAN = { active=false, location="", waiting_for_mobs=false, found_mobs=false }
local PROCESSED_LINES = {}

local function disable_scan_triggers()
  EnableTrigger("qt_unified_line", false)
  EnableTrigger("qt_unified_end", false)
  SCAN.active = false
  SCAN.waiting_for_mobs = false
  OSCAN.active = false
  OSCAN.waiting_for_items = false
  dprint("Unified triggers disabled")
end

local function clear_processed_lines()
  PROCESSED_LINES = {}
  dprint("Cleared processed lines")
end

-- ===== Auto Oscan/Scan on Stop Running =====
function qt_auto_scan(name, line, wildcards)
  if not QT.auto_oscan then
    dprint("Auto scan disabled")
    return
  end
  
  if OSCAN.active or SCAN.active then
    dprint("Scan already active, skipping auto scan")
    return
  end
  
  local current_time = os.time()
  if QT.last_scan_time and (current_time - QT.last_scan_time) < QT.scan_cooldown then
    dprint("Scan cooldown active (%d seconds remaining)", QT.scan_cooldown - (current_time - QT.last_scan_time))
    return
  end
  
  local has_junkyard = false
  local has_quest_mob = false
  
  for _, r in ipairs(QT.rows) do
    if r.type == "Junkyard" or r.type == "GJunkyard" then
      has_junkyard = true
    elseif r.type == "Quest" or r.type == "Global" or r.type == "Expedition" then
      has_quest_mob = true
    end
  end
  
  if has_junkyard then
    dprint("Auto oscan triggered - sending oscan #quest")
    Send("oscan #quest")
    QT.last_scan_time = current_time
  end
  
  if has_quest_mob then
    dprint("Auto scan triggered - sending scan @qt")
    Send("scan @qt")
    QT.last_scan_time = current_time
  end
  
  if not has_junkyard and not has_quest_mob then
    dprint("No active quests, skipping scan")
  end
end

function qt_oscan_nothing_handler(name, line, wildcards)
  dprint("qt_oscan_nothing_handler triggered")
  
  local has_junkyard = false
  for _, r in ipairs(QT.rows) do
    if r.type == "Junkyard" or r.type == "GJunkyard" then
      has_junkyard = true
      break
    end
  end
  
  if has_junkyard then
    ColourNote("yellow", "", "[QT] No item nearby")
  end
  
  disable_scan_triggers()
  dprint("Oscan found nothing - scan ended")
end

-- ===== UNIFIED Scan Handlers =====
function qt_unified_begin(name, line, wildcards)
  dprint("qt_unified_begin triggered")
  clear_processed_lines()
  
  local has_quest_mob = false
  for _, r in ipairs(QT.rows) do
    if r.type == "Quest" or r.type == "Global" or r.type == "Expedition" then
      has_quest_mob = true
      dprint("  Found quest mob in tracker")
      break
    end
  end
  
  local has_junkyard = false
  for _, r in ipairs(QT.rows) do
    if r.type == "Junkyard" or r.type == "GJunkyard" then
      has_junkyard = true
      dprint("  Found junkyard item in tracker")
      break
    end
  end
  
  if has_quest_mob then
    SCAN.active = true
    SCAN.location = "here"
    SCAN.waiting_for_mobs = true
    SCAN.found_mobs = false
    dprint("Scan: ACTIVATED for quest mobs at 'here'")
  end
  
  if has_junkyard then
    OSCAN.active = true
    OSCAN.location = "here"
    OSCAN.waiting_for_items = true
    OSCAN.found_items = false
    dprint("Oscan: ACTIVATED for junkyard items at 'here'")
  end
  
  if has_quest_mob or has_junkyard then
    EnableTrigger("qt_unified_line", true)
    EnableTrigger("qt_unified_end", true)
  end
end

function qt_unified_nearby_begin(name, line, wildcards)
  dprint("qt_unified_nearby_begin triggered")
  clear_processed_lines()
  
  local location = line:match("^(%d+%s+%w+)%s+you see") or "nearby"
  
  local has_quest_mob = false
  for _, r in ipairs(QT.rows) do
    if r.type == "Quest" or r.type == "Global" or r.type == "Expedition" then
      has_quest_mob = true
      break
    end
  end
  
  local has_junkyard = false
  for _, r in ipairs(QT.rows) do
    if r.type == "Junkyard" or r.type == "GJunkyard" then
      has_junkyard = true
      break
    end
  end
  
  if has_quest_mob then
    SCAN.active = true
    SCAN.location = location
    SCAN.waiting_for_mobs = true
    SCAN.found_mobs = false
    dprint("Scan: ACTIVATED for quest mobs at '%s'", location)
  end
  
  if has_junkyard then
    OSCAN.active = true
    OSCAN.location = location
    OSCAN.waiting_for_items = true
    OSCAN.found_items = false
    dprint("Oscan: ACTIVATED for junkyard items at '%s'", location)
  end
  
  if has_quest_mob or has_junkyard then
    EnableTrigger("qt_unified_line", true)
    EnableTrigger("qt_unified_end", true)
  end
end

function qt_unified_line_handler(name, line, wildcards)
  local raw_text = wildcards[1]
  if not raw_text or raw_text == "" then return end
  
  raw_text = strip_ansi(raw_text)
  raw_text = clean_capture(raw_text)
  local line_key = raw_text:lower()
  
  if PROCESSED_LINES[line_key] then
    dprint("Line already processed, skipping")
    return
  end
  
  local is_mob = raw_text:match("%(Level%s+%d+%)")
  
  if SCAN.active and SCAN.waiting_for_mobs and is_mob then
    dprint("Processing as potential quest mob: %s", raw_text)
    
    local mob_name = raw_text:match("%(Level%s+%d+%)%([EGN]%)%([A-Z]%)%s+(.+)")
    if not mob_name then
      mob_name = raw_text:match("%(Level%s+%d+%)%([EGN]%)%s+(.+)")
    end
    if not mob_name then
      mob_name = raw_text:match("%)%s+(.+)$")
    end
    
    if mob_name then
      mob_name = clean_capture(mob_name)
      local mob_for_match = mob_name:match("^(.+)%s+%(%d+%)%s*$") or mob_name
      local mob_lower = mob_for_match:lower()
      
      for _, r in ipairs(QT.rows) do
        if r.type == "Quest" or r.type == "Global" or r.type == "Expedition" then
          local tracker_mob_lower = (r.mob or ""):lower()
          
          if mob_lower:find(tracker_mob_lower, 1, true) or tracker_mob_lower:find(mob_lower, 1, true) then
            local tag = "[Q]"
            if r.type == "Global" then tag = "[GQ]"
            elseif r.type == "Expedition" then tag = "[EXP]" end
            
            local location_tag = ""
            if SCAN.location ~= "here" then
              location_tag = " [" .. SCAN.location .. "]"
            end
            
            PROCESSED_LINES[line_key] = true
            ColourNote("cyan", "", "     - " .. mob_name .. location_tag .. " ", "yellow", "", tag)
            SCAN.found_mobs = true
            dprint("MATCHED quest mob!")
            return
          end
        end
      end
    end
  end
  
  if OSCAN.active and OSCAN.waiting_for_items and not is_mob then
    dprint("Processing as potential junkyard item: %s", raw_text)
    
    local item_lower = raw_text:lower()
    
    for _, r in ipairs(QT.rows) do
      if r.type == "Junkyard" or r.type == "GJunkyard" then
        local tracker_item_lower = (r.mob or ""):lower()
        
        if item_lower:find(tracker_item_lower, 1, true) or tracker_item_lower:find(item_lower, 1, true) then
          local tag = r.type == "Junkyard" and "[JY]" or "[GJY]"
          
          local location_tag = ""
          if OSCAN.location ~= "here" then
            location_tag = " [" .. OSCAN.location .. "]"
          end
          
          PROCESSED_LINES[line_key] = true
          ColourNote("cyan", "", "     - " .. raw_text .. location_tag .. " ", "yellow", "", tag)
          OSCAN.found_items = true
          dprint("MATCHED junkyard item!")
          return
        end
      end
    end
  end
  
  dprint("No match for: %s", raw_text)
end

function qt_unified_end_handler(name, line, wildcards)
  dprint("Unified scan ended")
  
  if SCAN.active and SCAN.waiting_for_mobs and not SCAN.found_mobs then
    ColourNote("yellow", "", "[QT] No target found")
  end
  
  if OSCAN.active and OSCAN.waiting_for_items and not OSCAN.found_items then
    ColourNote("yellow", "", "[QT] No item nearby")
  end
  
  disable_scan_triggers()
end

-- ===== Where command auto-navigation =====
local WHERE = { active=false, found_first=false, seen_blank=false }
local function _qt_where_enable_line(on) EnableTrigger("qt_where_line", on and true or false) end
local function _qt_where_enable_end(on) EnableTrigger("qt_where_end", on and true or false) end

function qt_where_begin(name, line, wildcards)
  WHERE.active = true
  WHERE.found_first = false
  WHERE.seen_blank = false
  _qt_where_enable_line(true)
  _qt_where_enable_end(true)
  dprint("Where search detected, waiting for first result")
end

function qt_where_line(name, line, wildcards)
  if not WHERE.active or WHERE.found_first then return end
  
  local raw_line = line or ""
  line = strip_ansi(raw_line)
  
  if line:match("^%s*$") then return end
  
  local mob, room = line:match("^(.-)%s%s%s%s%s%s%s%s%s%s+(.+)$")
  if not mob then mob, room = line:match("^(.-)%s%s%s%s%s+(.+)$") end
  if not mob then mob, room = line:match("^(.-)%s%s+(.+)$") end
  
  if mob and room then
    mob = clean_capture(mob)
    room = clean_capture(room)
    room = room:gsub("%s*%([xX]%d+%)%s*$", "")
    
    WHERE.found_first = true
    dprint("Parsed: mob='%s' room='%s'", mob, room)
    
    local room_lower = norm_lower(room)
    Execute("mapper find " .. room_lower)
  end
end

function qt_where_end(name, line, wildcards)
  if WHERE.active then
    if WHERE.seen_blank or WHERE.found_first then
      WHERE.active = false
      WHERE.found_first = false
      WHERE.seen_blank = false
      _qt_where_enable_line(false)
      _qt_where_enable_end(false)
      dprint("Where search ended")
    else
      WHERE.seen_blank = true
    end
  end
end

  ]]>
  </script>
  
</muclient>