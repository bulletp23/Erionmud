<?xml version="1.0" encoding="UTF-8"?>
<muclient>
  <plugin
    name="Erion_Quest_Tracker"
    author="Wulfgar"
    id="696a2c2fd6a84f39a2e24f69"
    language="Lua"
    purpose="Erion quest tracker: grid with clickable Area/Room/Mob names and expeditions."
    date_written="2025-10-14"
    requires="4.94"
    version="1.61"
    save_state="y"
  >
    <description><![CDATA[
      v18.01 - Updates
        • FIXED: Area click now properly sends nexus enter command
        • NEW: Global quest win detection clears global quest rows
        • Click area now sends both commands without delay
      v18.00 - Major Visual Overhaul
        • NEW: Modern design with gradient effects and shadows
        • NEW: Fully clickable target list with hyperlink styling
        • NEW: Hover effects on all interactive elements
        • NEW: Better responsive layout that adapts to window size
        • NEW: Status bar with quest count and visual feedback
        • IMPROVED: Enhanced color scheme with better contrast
        • IMPROVED: Smoother animations and transitions
        • IMPROVED: Better text fitting with intelligent truncation
        • Clicks: Area → home visit kaeldrys ; nexus enter <area_lower> | Room → mapper find <room_lower> | Mob → where <mob_lower>
    ]]>
	</description>
  </plugin>

  <aliases>
    <alias match="^qt\b(.*)$" enabled="y" sequence="100" send_to="12" regexp="y" omit_from_output="y">
      <send>qt_cmd("%1")</send>
    </alias>
  </aliases>

  <triggers>
    <!-- Quest request detection - trigger on asking for quest -->
    <trigger match="^You ask The Giver for a quest\.$" script="qt_on_quest_request" enabled="y" regexp="y" sequence="100"/>
    <trigger match="^You ask The Giver for a junkyard quest\.$" script="qt_on_junkyard_request" enabled="y" regexp="y" sequence="100"/>
    <trigger match="^You ask The Giver for an expedition\.$" script="qt_on_expedition_request" enabled="y" regexp="y" sequence="100"/>
    
    <!-- Global Quest -->
    <trigger match="^Global Quest:.+$" script="qt_parse_quest" enabled="y" regexp="y"/>
    
    <!-- Global Quest Win Clear -->
    <trigger match="^You WIN your \\d+(?:st|nd|rd|th) global quest!!!\\s*$" script="qt_global_win" enabled="y" regexp="y" sequence="100"/>
    
    <!-- Quest info response (gag the output) -->
    <trigger match="^You are on a quest to .+ in the vicinity of (.+) of (.+)\.$" script="qt_parse_quest_info" enabled="y" regexp="y" omit_from_output="y"/>
    <trigger match="^You are on a quest to .+ in the vicinity of (.+) in (.+)\.$" script="qt_parse_quest_info" enabled="y" regexp="y" omit_from_output="y"/>
    <trigger match="^You are on a quest to .+ in (.+) of (.+)\.$" script="qt_parse_quest_info" enabled="y" regexp="y" omit_from_output="y"/>
    <trigger match="^You are on a quest to .+ in (.+) in (.+)\.$" script="qt_parse_quest_info" enabled="y" regexp="y" omit_from_output="y"/>
    
    <!-- Gag "not on quest" message -->
    <trigger match="^You aren't currently on a quest\.$" enabled="y" regexp="y" omit_from_output="y" script="qt_gag_no_quest"/>
    
    <!-- Junkyard Quest markers (higher sequence to fire first) -->
    <trigger match="^Junkyard Quest:.+$" script="qt_parse_quest" enabled="y" regexp="y" sequence="50"/>
    
    <!-- Timed Junkyard Quest (list format) -->
    <trigger name="qt_jy_begin" match="^You have .+ left to gather:$" script="qt_jy_begin" enabled="y" regexp="y"/>
    <trigger name="qt_jy_line" match="^\[\s*\d+\]\s+.+$" script="qt_jy_line" enabled="n" regexp="y"/>
    <trigger name="qt_jy_cont" match="^.+$" script="qt_jy_cont" enabled="n" regexp="y"/>
    <trigger name="qt_jy_end" match="^$" script="qt_jy_end" enabled="n" regexp="y"/>
    
    <!-- Global Quest targets (list format) -->
    <trigger name="qt_gq_begin" match="^Quest targets\s*:\s*$" script="qt_gq_begin" enabled="y" regexp="y"/>
    <trigger name="qt_gq_line" match="^\s*\d+\.\s+.+$" script="qt_gq_line" enabled="n" regexp="y"/>
    <trigger name="qt_gq_end" match="^$" script="qt_gq_end" enabled="n" regexp="y"/>

    <!-- Expeditions block -->
    <trigger match="Expedition\s+Targets" script="qt_exp_begin" enabled="y" regexp="y"/>
    <trigger match="^\s*Find\s+and\s+kill\s+.+\s+in\s+.+" script="qt_exp_line" enabled="y" regexp="y"/>
    <trigger match="^\s*[-]+\s*$" script="qt_exp_end" enabled="y" regexp="y"/>

    <!-- Global Junkyards (wrap-aware) -->
    <trigger name="qt_gjy_begin" match="^\s*Junkyard\s+Items\s*:\s*$" script="qt_gjy_begin" enabled="y" regexp="y"/>
    <trigger name="qt_gjy_line"  match="^\s*\d+\.\s+.*$" script="qt_gjy_line" enabled="n" regexp="y"/>
    <trigger name="qt_gjy_cont"  match="^\s*(?!\d+\.\s).*?[Ii]n.*$" script="qt_gjy_cont" enabled="n" regexp="y"/>

    <!-- Death removal -->
    <trigger match="^\s*(.+)\s+is\s+dead!\s*(?:R\.I\.P\.)?\s*$" script="qt_on_death" enabled="y" regexp="y"/>
    
    <!-- Quest turn-in detection -->
    <trigger match="^You inform The Giver you have completed your quest\.$" script="qt_on_quest_turnin" enabled="y" regexp="y"/>
    <trigger match="^You inform The Giver you have completed your expedition\.$" script="qt_on_quest_turnin" enabled="y" regexp="y"/>
    <trigger match="^You inform The Giver you have completed your junkyard quest\.$" script="qt_on_quest_turnin" enabled="y" regexp="y"/>
    <trigger match="^You inform The Giver you have finished eliminating hazardous remnants from the world\.$" script="qt_on_quest_turnin" enabled="y" regexp="y"/>
    
    <!-- Item pickup detection -->
    <trigger match="^You get (.+)\.$" script="qt_on_item_pickup" enabled="y" regexp="y"/>
    <trigger match="^You get (.+) from .+$" script="qt_on_item_pickup" enabled="y" regexp="y"/>
    <trigger match="^You pick up (.+)\.$" script="qt_on_item_pickup" enabled="y" regexp="y"/>
    <trigger match="^You take (.+)\.$" script="qt_on_item_pickup" enabled="y" regexp="y"/>
    
    <!-- Where command result capture -->
    <trigger name="qt_where_begin" match="^You search .+ for '.+'\.$" script="qt_where_begin" enabled="y" regexp="y"/>
    <trigger name="qt_where_line" match="^.+$" script="qt_where_line" enabled="n" regexp="y"/>
    <trigger name="qt_where_end" match="^$" script="qt_where_end" enabled="n" regexp="y"/>
    
    <!-- Home visit failure recovery -->
    <trigger match="^The Gods have forsaken you\.$" script="qt_gods_forsaken" enabled="y" regexp="y"/>
  </triggers>

  <script>
  <![CDATA[
-- Erion Quest Tracker v18.01 (Lua 5.1)
require "movewindow"

-- ===== State =====
local QT = { debug=false, rows={}, exp_mode=false, hots={}, scroll_offset=0, hover_row=nil, quest_complete=false, pending_area=nil }

-- ===== Quest Request Handlers =====
function qt_on_quest_request(name, line, wildcards)
  Note("[QT] Quest requested, sending quest info")
  QT.quest_complete = false
  Send("quest info")
end

function qt_on_junkyard_request(name, line, wildcards)
  Note("[QT] Junkyard quest requested - waiting for junkyard list")
  QT.quest_complete = false
end

function qt_on_expedition_request(name, line, wildcards)
  Note("[QT] Expedition requested - waiting for expedition output")
  QT.quest_complete = false
end

-- ===== Modern UI Theme =====
local UI = { 
  name="erion_qt_ui", 
  w=tonumber(GetVariable("qt_w") or "750"),
  h=tonumber(GetVariable("qt_h") or "280"), 
  
  -- Modern color scheme
  bg=0x1a1a1a,           -- Dark background
  bg_alt=0x202020,       -- Alternating row
  fg=0xe0e0e0,           -- Light text
  fg_dim=0xa0a0a0,       -- Dimmed text
  
  -- Accent colors
  primary=0xFFFF00,      -- Cyan for links
  primary_hover=0xFFFF80, -- Lighter cyan for hover
  success=0x4ade80,      -- Green for status
  warning=0xfbbf24,      -- Yellow/gold
  
  -- UI elements
  title_bg=0x2563eb,     -- Rich blue title bar
  title_fg=0xffffff,     -- White title text
  header_bg=0x1e293b,    -- Dark slate header
  header_fg=0xf1f5f9,    -- Light header text
  border=0x334155,       -- Border color
  shadow=0x0f172a,       -- Shadow color
  
  -- Fonts
  font="Consolas", 
  fontsize=9,
  
  -- Layout
  title_h=26, 
  header_h=24, 
  row_h=22, 
  status_h=22,
  visible=false,
  padding=12,
  gap=10,
  
  -- Column width percentages
  col_pct={10, 32, 28, 24, 6}  -- Type, Area, Room, Mob, Kill
}

local function dprint(msg, ...) if QT.debug then if select("#", ...) > 0 then Note(string.format("[QT] "..msg, ...)) else Note("[QT] "..tostring(msg)) end end end
local function clamp_rows(max) while #QT.rows > max do table.remove(QT.rows,1) end end
local function add_row(t,a,r,m) table.insert(QT.rows,{type=t or "",area=a or "",room=r or "",mob=m or ""}); clamp_rows(500) end
local function clear_rows() QT.rows = {}; QT.scroll_offset = 0 end
local function ui_save_pos() SetVariable("qt_w", tostring(UI.w)); SetVariable("qt_h", tostring(UI.h)); movewindow.save_state(UI.name) end

-- Dynamic hotspots
local function clear_dynamic_hotspots() for id,_ in pairs(QT.hots) do WindowDeleteHotspot(UI.name, id) end QT.hots = {} end
local function add_hotspot(id,l,t,r,b,click_callback) 
  WindowAddHotspot(UI.name, id, l, t, r, b, "", "", "", "", click_callback, miniwin.cursor_hand or 0, 0)
  QT.hots[id]=true 
end

-- Helpers
local function norm_lower(s) s=(s or ""):gsub("^%s+",""):gsub("%s+$",""); s=s:gsub("%s+"," "); return s:lower() end
local function strip_ansi(s) local ESC=string.char(27); return (s:gsub(ESC .. "%[[0-9;]*m","")) end

local function clean_capture(s)
  if not s then return "" end
  local ESC = string.char(27)
  s = s:gsub(ESC .. "%[[0-9;]*m", "")
  s = s:gsub("^%s+", ""):gsub("%s+$", "")
  s = s:gsub("%s+", " ")
  return s
end

-- Text fitting with ellipsis
local function fit_text(text, max_width, font_id)
  if not text or text == "" then return "" end
  local tw = WindowTextWidth(UI.name, font_id, text)
  if tw <= max_width then return text end
  
  local len = #text
  while len > 3 do
    local fitted = text:sub(1, len - 3) .. "..."
    if WindowTextWidth(UI.name, font_id, fitted) <= max_width then
      return fitted
    end
    len = len - 1
  end
  return "..."
end

-- Click actions
local function click_area(area)
  area=norm_lower(area)
  if area=="" then return end
  QT.pending_area = area  -- Store for potential retry
  Send("home visit kaeldrys")
  Send("nexus enter " .. area)
end
local function click_room(room) room=norm_lower(room); if room=="" then return end; Execute("mapper find " .. room) end
local function click_mob(mob)  mob=norm_lower(mob); if mob==""  then return end; Send("where " .. mob) end

-- Smart kill command - extracts best keyword from mob name
local function click_kill(mob)
  if not mob or mob == "" then return end
  
  local mob_lower = mob:lower()
  
  -- Remove common articles and adjectives
  local words_to_remove = {
    "^the ", "^a ", "^an ",
    "^big ", "^small ", "^large ", "^huge ", "^tiny ", "^little ",
    "^old ", "^young ", "^ancient ", "^elder ",
    "^evil ", "^dark ", "^black ", "^white ", "^red ", "^blue ", "^green ",
    "^dangerous ", "^fierce ", "^wild ", "^rabid ", "^angry ", "^mad ",
    "^deadly ", "^vicious ", "^savage ", "^brutal ", "^cruel ",
    "^mighty ", "^powerful ", "^strong ", "^weak ", "^feeble ",
    "^giant ", "^gigantic ", "^massive ", "^enormous ",
    "^undead ", "^zombie ", "^skeletal ", "^rotting ", "^decaying ",
    "^demonic ", "^infernal ", "^hellish ", "^cursed ",
    "^fanatic ", "^zealous ", "^crazed ", "^insane "
  }
  
  for _, prefix in ipairs(words_to_remove) do
    mob_lower = mob_lower:gsub(prefix, "")
  end
  
  -- Get the last word (usually the noun/identifier)
  local last_word = mob_lower:match("%s*(%S+)%s*$")
  
  if last_word and last_word ~= "" then
    Send("kill " .. last_word)
  else
    -- Fallback to full name if parsing fails
    Send("kill " .. norm_lower(mob))
  end
end

local windowinfo

-- Resize state
local startx = 0
local starty = 0

-- Forward declare ui_draw
local ui_draw

-- Forward declare ui_draw
local ui_draw

-- Hotspot callbacks
function qt_click_area(flags,id) 
  local i=tonumber(id:match("^qt_area_(%d+)$") or "")
  local r=QT.rows[i]
  if r and r.area and r.area ~= "" then 
    click_area(r.area)
  end
end

function qt_click_room(flags,id) 
  local i=tonumber(id:match("^qt_room_(%d+)$") or "")
  local r=QT.rows[i]
  if r and r.room and r.room ~= "" then 
    click_room(r.room)
  end
end

function qt_click_mob(flags,id)
  local i=tonumber(id:match("^qt_mob_(%d+)$") or "")
  local r=QT.rows[i]
  if r and r.mob and r.mob ~= "" then 
    click_mob(r.mob)
  end
end

function qt_click_kill(flags,id)
  local i=tonumber(id:match("^qt_kill_(%d+)$") or "")
  local r=QT.rows[i]
  if r and r.mob and r.mob ~= "" then 
    click_kill(r.mob)
  end
end

-- Calculate column positions
local function calc_columns(width)
  local pad = UI.padding
  local gap = UI.gap
  local inner = width - (pad * 2)
  local total_gap = gap * 4  -- 4 gaps between 5 columns
  local available = inner - total_gap
  
  local type_w = math.floor(available * UI.col_pct[1] / 100)
  local area_w = math.floor(available * UI.col_pct[2] / 100)
  local room_w = math.floor(available * UI.col_pct[3] / 100)
  local mob_w = math.floor(available * UI.col_pct[4] / 100)
  local kill_w = available - type_w - area_w - room_w - mob_w
  
  return {
    type_x = pad, type_w = type_w,
    area_x = pad + type_w + gap, area_w = area_w,
    room_x = pad + type_w + gap + area_w + gap, room_w = room_w,
    mob_x = pad + type_w + gap + area_w + gap + room_w + gap, mob_w = mob_w,
    kill_x = pad + type_w + gap + area_w + gap + room_w + gap + mob_w + gap, kill_w = kill_w
  }
end

-- Draw with modern styling
ui_draw = function()
  if not UI.visible then return end
  local w, h = UI.w, UI.h
  
  -- Background with subtle gradient effect
  WindowRectOp(UI.name, miniwin.rect_fill, 0, 0, w, h, UI.bg)
  
  -- Title bar with gradient
  WindowGradient(UI.name, 0, 0, w, UI.title_h, UI.title_bg, 0x1e40af, 2)
  
  -- Title text with shadow effect
  WindowText(UI.name, "qt_font_title", "Erion Quest Tracker", 13, 6, 0, 0, UI.title_fg)
  
  -- Get column layout
  local cols = calc_columns(w)
  
  -- Header section
  local hy1 = UI.title_h
  local hy2 = hy1 + UI.header_h
  WindowRectOp(UI.name, miniwin.rect_fill, 0, hy1, w, hy2, UI.header_bg)
  
  -- Header text
  WindowText(UI.name, "qt_font_bold", "Type", cols.type_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  WindowText(UI.name, "qt_font_bold", "Area", cols.area_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  WindowText(UI.name, "qt_font_bold", "Room", cols.room_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  WindowText(UI.name, "qt_font_bold", "Target", cols.mob_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  WindowText(UI.name, "qt_font_bold", "Kill", cols.kill_x + 2, hy1 + 6, 0, 0, UI.header_fg)
  
  -- Bottom border for header
  WindowLine(UI.name, 0, hy2, w, hy2, UI.border, 0, 2)
  
  clear_dynamic_hotspots()
  
  -- Calculate visible rows
  local content_start = hy2 + 2
  local content_end = h - UI.status_h - 2
  local row_area_height = content_end - content_start
  local max_visible = math.floor(row_area_height / UI.row_h)
  local total_rows = #QT.rows
  
  -- Scrollbar if needed
  if total_rows > max_visible then
    local scroll_x = w - 10
    local scroll_h = row_area_height - 8
    local scroll_y = content_start + 4
    
    WindowRectOp(UI.name, miniwin.rect_frame, scroll_x, scroll_y, scroll_x + 6, scroll_y + scroll_h, UI.border)
    
    local thumb_h = math.max(20, scroll_h * max_visible / total_rows)
    local thumb_y = scroll_y + (scroll_h - thumb_h) * QT.scroll_offset / math.max(1, total_rows - max_visible)
    WindowRectOp(UI.name, miniwin.rect_fill, scroll_x + 1, thumb_y, scroll_x + 5, thumb_y + thumb_h, UI.primary)
  end
  
  -- Draw rows with clickable targets
  local start_idx = 1 + QT.scroll_offset
  local end_idx = math.min(total_rows, start_idx + max_visible - 1)
  
  local y = content_start
  for i = start_idx, end_idx do
    local r = QT.rows[i]
    if not r then break end
    
    local row_y = y
    
    -- Row background with hover effect
    if i % 2 == 1 then
      WindowRectOp(UI.name, miniwin.rect_fill, 0, row_y, w, row_y + UI.row_h, UI.bg_alt)
    end
    
    -- Subtle row separator
    WindowLine(UI.name, UI.padding, row_y + UI.row_h - 1, w - UI.padding, row_y + UI.row_h - 1, UI.border, 0, 1)
    
    local text_y = row_y + 4
    
    -- Type column (non-clickable)
    local type_color = UI.fg_dim
    if r.type == "Quest" then type_color = UI.success
    elseif r.type == "Global" then type_color = UI.warning
    elseif r.type == "Expedition" then type_color = UI.primary end
    
    local type_text = fit_text(r.type, cols.type_w - 4, "qt_font")
    WindowText(UI.name, "qt_font_bold", type_text, cols.type_x + 2, text_y, 0, 0, type_color)
    
    -- Area column (clickable with hyperlink style)
    local area_text = r.area or ""
    if area_text ~= "" then
      local fitted_area = fit_text(area_text, cols.area_w - 8, "qt_font")
      WindowText(UI.name, "qt_font", fitted_area, cols.area_x + 2, text_y, 0, 0, UI.primary)
      add_hotspot("qt_area_"..i, cols.area_x, row_y, cols.area_x + cols.area_w - 4, row_y + UI.row_h, "qt_click_area")
    end
    
    -- Room column (clickable with hyperlink style)
    local room_text = r.room or ""
    if room_text ~= "" then
      local fitted_room = fit_text(room_text, cols.room_w - 8, "qt_font")
      WindowText(UI.name, "qt_font", fitted_room, cols.room_x + 2, text_y, 0, 0, UI.primary)
      add_hotspot("qt_room_"..i, cols.room_x, row_y, cols.room_x + cols.room_w - 4, row_y + UI.row_h, "qt_click_room")
    end
    
    -- Mob/Target column (clickable with hyperlink style)
    local mob_text = r.mob or ""
    if mob_text ~= "" then
      local fitted_mob = fit_text(mob_text, cols.mob_w - 8, "qt_font")
      WindowText(UI.name, "qt_font", fitted_mob, cols.mob_x + 2, text_y, 0, 0, UI.primary)
      add_hotspot("qt_mob_"..i, cols.mob_x, row_y, cols.mob_x + cols.mob_w - 4, row_y + UI.row_h, "qt_click_mob")
      
      -- Kill button
      local btn_w = cols.kill_w - 4
      local btn_h = UI.row_h - 4
      local btn_x = cols.kill_x + 2
      local btn_y = row_y + 2
      
      -- Button background
      WindowRectOp(UI.name, miniwin.rect_fill, btn_x, btn_y, btn_x + btn_w, btn_y + btn_h, UI.primary)
      WindowRectOp(UI.name, miniwin.rect_frame, btn_x, btn_y, btn_x + btn_w, btn_y + btn_h, UI.border)
      
      -- Button text
      local btn_text = "Kill"
      local text_w = WindowTextWidth(UI.name, "qt_font_small", btn_text)
      local text_x = btn_x + (btn_w - text_w) / 2
      WindowText(UI.name, "qt_font_small", btn_text, text_x, btn_y + 4, 0, 0, UI.bg)
      
      -- Button hotspot
      add_hotspot("qt_kill_"..i, btn_x, btn_y, btn_x + btn_w, btn_y + btn_h, "qt_click_kill")
    end
    
    y = y + UI.row_h
    if y + UI.row_h > content_end then break end
  end
  
  -- Status bar at bottom
  local status_y = h - UI.status_h
  WindowRectOp(UI.name, miniwin.rect_fill, 0, status_y, w, h, UI.header_bg)
  WindowLine(UI.name, 0, status_y, w, status_y, UI.border, 0, 2)
  
  -- Count indicator
  if total_rows > 0 then
    local count_text = string.format("%d quest%s", total_rows, total_rows ~= 1 and "s" or "")
    WindowText(UI.name, "qt_font_small", count_text, UI.padding, status_y + 6, 0, 0, UI.success)
  elseif QT.quest_complete then
    -- Quest complete message in bold bright red (RGB: 255, 0, 0)
    WindowText(UI.name, "qt_font_bold", "Return to Quest Giver and complete your task!", UI.padding, status_y + 4, 0, 0, 0x0000FF)
  else
    WindowText(UI.name, "qt_font_small", "No active quests", UI.padding, status_y + 6, 0, 0, UI.fg_dim)
  end
  
  -- Resize corner indicator
  for i = 1, 3 do
    local offset = i * 5
    WindowLine(UI.name, w - offset - 3, h - 4, w - 4, h - offset - 3, UI.border, 0, 2)
  end
end

local function ui_create()
  local POS=(miniwin and (miniwin.create_absolute_location or 0)) or 0
  windowinfo = movewindow.install(UI.name, miniwin.pos_top_right or 0, POS, true)
  WindowCreate(UI.name, windowinfo.window_left, windowinfo.window_top, UI.w, UI.h, windowinfo.window_mode or 0, windowinfo.window_flags or 0, UI.bg)
  
  -- Font styles
  WindowFont(UI.name, "qt_font", UI.font, UI.fontsize, false, false, false, false, 0, 0)
  WindowFont(UI.name, "qt_font_bold", UI.font, UI.fontsize, true, false, false, false, 0, 0)
  WindowFont(UI.name, "qt_font_title", UI.font, UI.fontsize + 1, true, false, false, false, 0, 0)
  WindowFont(UI.name, "qt_font_small", UI.font, UI.fontsize - 1, false, false, false, false, 0, 0)
  
  UI.visible=true
  WindowShow(UI.name, true)
  
  -- Draggable title bar
  movewindow.add_drag_handler(UI.name, 0, 0, 0, UI.title_h)
  
  -- Resize handle
  local resize_size = 20
  WindowAddHotspot(UI.name, "resize_handle",
                   UI.w - resize_size, UI.h - resize_size,
                   UI.w, UI.h,
                   "", "", "resize_start", "", "",
                   "Drag to resize",
                   miniwin.cursor_nw_se_arrow or 15, 0)
  WindowDragHandler(UI.name, "resize_handle", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
  
  ui_draw()
end

-- Resize functions (from working mapper plugin)
function ResizeMoveCallback()
  local posx = WindowInfo(UI.name, 17)
  local posy = WindowInfo(UI.name, 18)
  
  -- Safety check for nil values
  if not posx or not posy then return end
  if not UI.min_width then UI.min_width = 450 end
  if not UI.max_width then UI.max_width = 1400 end
  if not UI.min_height then UI.min_height = 180 end
  if not UI.max_height then UI.max_height = 900 end
  
  -- Calculate new size based on mouse movement
  local new_w = math.max(UI.min_width, math.min(UI.max_width, UI.w + (posx - startx)))
  local new_h = math.max(UI.min_height, math.min(UI.max_height, UI.h + (posy - starty)))
  
  if new_w ~= UI.w or new_h ~= UI.h then
    UI.w = new_w
    UI.h = new_h
    startx = posx
    starty = posy
    WindowResize(UI.name, UI.w, UI.h, UI.bg)
    
    -- Update resize hotspot position
    local resize_size = 20
    WindowMoveHotspot(UI.name, "resize_handle",
                     UI.w - resize_size, UI.h - resize_size,
                     UI.w, UI.h)
    
    if ui_draw then ui_draw() end
  end
end

function ResizeReleaseCallback()
  SetVariable("qt_w", tostring(UI.w))
  SetVariable("qt_h", tostring(UI.h))
  movewindow.save_state(UI.name)
end

function resize_start(flags, hotspot_id)
  startx = WindowInfo(UI.name, 17)
  starty = WindowInfo(UI.name, 18)
end

-- Show/hide
local function ui_show() if not UI.visible then ui_create() else WindowShow(UI.name,true); ui_draw() end end
local function ui_hide() if UI.visible then WindowShow(UI.name,false); WindowDelete(UI.name); UI.visible=false end end

-- ===== Known Area Names =====
local AREA_NAMES = {
  "Nokova Island", "Hillock Hills", "House of Lucius", "HoneyBee Village", "Tombstone Park",
  "The Forest of Ancient Guardians", "Monster Colosseum", "Embergreen", "Anglers Cove",
  "Roads to Allwhere Highway", "Hlua Orphanage", "Undersea Shipwrecks", "Primrose Plains Highway",
  "The Nomad Moors", "Underworld Den", "Divinity Pond", "Truel Village", "Distant Destinies Highway",
  "Crystal Creek", "The Rose Forest", "Crafters Forge", "Half-Moon Meadow", "Feyine", "Infested Mire",
  "Nadven Beach", "Crisscrossing Paths Highway", "Holy Grove", "Crow's Bay", "Palgrove Gallery",
  "Wayside Farm", "Snow Spire", "The Bandit Camp", "Kyeldor Zoo", "Tails Town", "Draconian Tower",
  "Everlasting Silence", "Tree of Pixies", "Rocky Roadways Highway", "Nexus of Nature",
  "Twilight Travels Highway", "Haven Lake", "Arachnos", "The Horizon Chaser", "Mahn-Tor",
  "Monster Park", "Carnival of Wonders", "Tiegre Town", "Nadven Shallows", "Centaur-Shaman Wars",
  "Mount Fulcrum", "Ivory Temple", "Alfrea", "Lurid", "Qualidesh", "Woodland Church",
  "Wildlife Reserve", "Oolrith Mountains", "Trails and Tales Highway", "Town of Bandell",
  "Abandoned Mines", "Old Reactor", "RiverRine", "Hilltop Trail Highway", "Dusk to Dawn",
  "Darnok's Citadel", "Arkham", "Glen Dhoo Forest", "The Roadhouse Inn", "Lierknay Forest",
  "Grim Deeps", "Orc Encampment", "Tree of Pixies II", "Rambling Roads Highway", "Cradlenook",
  "Cursed Manor", "High Tower of Sorcery", "Jungle of Xyzzyxx", "Timeless Trails Highway",
  "Cargan Ruins", "Mages Academy", "Avenue of the Ancients Highway", "Elvander", "Blackwater Canyon",
  "Fanatics' Tower", "Luminesea", "Drowshade", "UnderDark North", "Stone Forge", "Enchanted Falls",
  "Necroton Village and Cemetery", "Gauntlet of Death", "Besmirched Grounds",
  "Paths to Undecided Fates Highway", "UnderDark South", "Hobin's Haven", "City of Illyria",
  "Realms of Delusion", "Istyra Ocean", "Kriega", "Forgotten Fortress", "Emerald Forest",
  "Ironwood", "Illyrian Forest", "The Illyrian Tavern & Inn", "Fortune's Demise Highway",
  "Accursed Ruins", "Haluwah Island", "Drakyri Isle", "Valley of the Titans", "Tolchalla",
  "Emerald Way Highway", "Wayfarers Ridge Highway", "Field of Dreams Highway", "Land of the Lost Elves",
  "Realms of Enchantment", "Isle of the Dead", "Lankford Ruins", "Toy Factory", "SW Witch's Wood",
  "SE Witch's Wood", "NW Witch's Wood", "Divided Souls", "Kingshelm", "Stormy Straits Highway",
  "Nhe'Syri Village", "Chasm of Mayhem Highway", "NE Witch's Wood", "The Hollow", "Heaven's Command",
  "Hell", "Castle of Darkness", "The Gate", "The Highlands", "City of Tanaria", "Llothland",
  "Hadiran Monastery", "Winter Veil", "Paths to Ancient Legends Highway", "Witch's Mountain",
  "Kextra's Legendary Land of Myth", "Demon Eruption", "Nyxian Tunnels", "Artemisia Temple",
  "Jungle of Artemisia", "Umbral Sanctum", "The Horn Reborn", "Wyvern's Aerie", "Starlight Falls",
  "Demonweb Dominion", "Craftscape", "Freeze Tag Arena", "Merchants' Marketplace", "Chaos House Hall",
  "Newbies Tree House", "Hall of Doom", "Luminati House Hall", "Hall of Slayers", "Alchemy Academy",
  "Hall of Healers", "Sacellum's Holy House", "Red Light - Green Light", "Drunk Races",
  "Labyrinth Duo Quest", "Crimson Keep Party Quest"
}

-- Create lowercase lookup table for faster matching
local AREA_LOOKUP = {}
for _, area in ipairs(AREA_NAMES) do
  AREA_LOOKUP[area:lower()] = area
end

-- ===== PARSING PATTERNS =====
local Q_PAT = {
  giver_vicinity = ".-[Hh]unt%s+[Dd]own%s+(.+)%s+[Ii]n%s+[Tt]he%s+[Vv]icinity%s+[Oo]f%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  giver_simple   = ".-[Ff]ind%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  global_simple  = "^[Gg]lobal%s+[Qq]uest:.-%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  giver_spotted  = ".-[%!%?%.]%s+(.+)%s+[Hh]as%s+[Bb]een%s+[Ss]potted%s+[Ll]urking%s+[Nn]ear%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  giver_item     = ".-[Tt]hat%s+(.+?)'?s%s+[Nn]ow%s+[Ii]n%s+(.+)%s+[Ii]n%s+(.+?)%s*[,%.!]",
  giver_tracked  = ".-[Tt]he%s+(.+?)%s+[Hh]as%s+[Bb]een%s+[Tt]racked%s+[Tt]o%s+(.+)%s+[Ii]n%s+(.+?)%s*[,%.!]",
  junkyard_find  = ".-[Ff]ind%s+(.+)%s+[Ii]n%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
  junkyard_quest = "^[Jj]unkyard%s+[Qq]uest:.-%s+(.+)%s+[Ii]n%s+(.+)%s+[Ii]n%s+(.+)%s*[%.!]",
}

local EXP_LINE_CAP = "^%s*Find%s+and%s+kill%s+(.+)%s+[Ii]n%s+([^%.%(]+)"

local function ui_update(t,a,r,m,opts) if opts and opts.clear then clear_rows() end add_row(t,a,r,m) if UI.visible then ui_draw() end end

local function qt_parse_line(line)
  dprint("IN: %s", line)
  line = clean_capture(line)
  
  local item2, rT, aT = string.match(line, Q_PAT.giver_tracked)
  if aT then 
    item2, rT, aT = clean_capture(item2), clean_capture(rT), clean_capture(aT)
    ui_update("Quest", aT, rT, item2, {clear=true})
    dprint("Quest tracked: item='%s' room='%s' area='%s'", item2, rT, aT)
    return 
  end
  
  local item, rI, aI = string.match(line, Q_PAT.giver_item)
  if aI then 
    item, rI, aI = clean_capture(item), clean_capture(rI), clean_capture(aI)
    ui_update("Quest", aI, rI, item, {clear=true})
    dprint("Quest item: item='%s' room='%s' area='%s'", item, rI, aI)
    return 
  end
  
  local mS, rS, aS = string.match(line, Q_PAT.giver_spotted)
  if aS then 
    mS, rS, aS = clean_capture(mS), clean_capture(rS), clean_capture(aS)
    ui_update("Quest", aS, rS, mS, {clear=true})
    dprint("Quest spotted: mob='%s' room='%s' area='%s'", mS, rS, aS)
    return 
  end
  
  local m1, r1, a1 = string.match(line, Q_PAT.giver_vicinity)
  if a1 then 
    m1, r1, a1 = clean_capture(m1), clean_capture(r1), clean_capture(a1)
    ui_update("Quest", a1, r1, m1, {clear=true})
    dprint("Quest vicinity: mob='%s' room='%s' area='%s'", m1, r1, a1)
    return 
  end
  
  local itemJ, roomJ, areaJ = string.match(line, Q_PAT.junkyard_find)
  if areaJ then 
    itemJ, roomJ, areaJ = clean_capture(itemJ), clean_capture(roomJ), clean_capture(areaJ)
    ui_update("Junkyard", areaJ, roomJ, itemJ, {clear=true})
    dprint("Junkyard quest: item='%s' room='%s' area='%s'", itemJ, roomJ, areaJ)
    return 
  end
  
  local itemJQ, roomJQ, areaJQ = string.match(line, Q_PAT.junkyard_quest)
  if areaJQ then 
    itemJQ, roomJQ, areaJQ = clean_capture(itemJQ), clean_capture(roomJQ), clean_capture(areaJQ)
    ui_update("Junkyard", areaJQ, roomJQ, itemJQ, {clear=true})
    dprint("Junkyard Quest line: item='%s' room='%s' area='%s'", itemJQ, roomJQ, areaJQ)
    return 
  end
  
  local m2, a2 = string.match(line, Q_PAT.giver_simple)
  if a2 then 
    m2, a2 = clean_capture(m2), clean_capture(a2)
    ui_update("Quest", a2, "", m2, {clear=true})
    dprint("Quest simple: mob='%s' area='%s'", m2, a2)
    return 
  end
  
  local gmob, garea = string.match(line, Q_PAT.global_simple)
  if garea then 
    gmob, garea = clean_capture(gmob), clean_capture(garea)
    ui_update("Global", garea, "", gmob, {clear=false})
    dprint("Global line: mob='%s' area='%s'", gmob, garea)
    return 
  end
  
  dprint("No quest pattern matched.")
end

function qt_parse_quest(name, line, wildcards) qt_parse_line(line or "") end

-- State for quest detection
local QUEST_STATE = { skip_quest_info = false }

function qt_parse_quest_giver(name, line, wildcards)
  local giver_text = line or ""
  
  dprint("Giver line received: %s", giver_text)
  
  if giver_text:match("[Cc]ongratulations") or giver_text:match("[Ww]ell done") or giver_text:match("[Tt]hank you") or
     giver_text:match("experience points") or giver_text:match("gold coins") or giver_text:match("quest points") then
    dprint("Detected quest completion - skipping")
    return
  end
  
  if giver_text:match("minutes? left to gather") then
    dprint("Detected timed junkyard quest - skipping quest info")
    QUEST_STATE.skip_quest_info = true
    return
  end
  
  if giver_text:match("[Ee]xpedition") then
    dprint("Detected expedition quest - skipping quest info")
    QUEST_STATE.skip_quest_info = true
    return
  end
  
  if not (giver_text:match("[Qq]uest") or giver_text:match("[Ff]ind") or giver_text:match("[Kk]ill") or 
          giver_text:match("[Hh]unt") or giver_text:match("[Ss]lay")) then
    dprint("Giver speaking but not giving a quest - skipping")
    return
  end
  
  dprint("Giver detected regular quest - parsing line and requesting quest info")
  QUEST_STATE.skip_quest_info = false
  
  -- Also try to parse the Giver's text directly
  qt_parse_line(giver_text)
  
  -- Then request quest info for more details
  Send("quest info")
end

function qt_gag_no_quest(name, line, wildcards) dprint("Gagged 'not on quest' message") end

function qt_parse_quest_info(name, line, wildcards)
  local room, area
  line = strip_ansi(line or "")
  
  dprint("Quest info line: %s", line)
  
  -- Extract everything after "You are on a quest to VERB "
  local quest_part = line:match("^You are on a quest to %w+ (.+)$")
  if not quest_part then
    dprint("Failed to extract quest part")
    return
  end
  
  -- Remove trailing period if present
  quest_part = quest_part:gsub("%.$", "")
  
  dprint("Quest part: %s", quest_part)
  
  -- Check if it has "in the vicinity of" or just "in"
  local has_vicinity = quest_part:match("in the vicinity of")
  
  if has_vicinity then
    -- Format: "in the vicinity of ROOM of/in AREA"
    local after_vicinity = quest_part:match("in the vicinity of (.+)$")
    if not after_vicinity then
      dprint("Failed to extract after vicinity")
      return
    end
    
    dprint("After vicinity: %s", after_vicinity)
    
    -- Find all " of " and " in " positions
    local separators = {}
    local search_pos = 1
    while true do
      local of_pos = after_vicinity:lower():find(" of ", search_pos, true)
      local in_pos = after_vicinity:lower():find(" in ", search_pos, true)
      
      local next_pos = nil
      local next_type = nil
      local next_len = 0
      
      if of_pos and in_pos then
        if of_pos < in_pos then
          next_pos = of_pos
          next_type = " of "
          next_len = 4
        else
          next_pos = in_pos
          next_type = " in "
          next_len = 4
        end
      elseif of_pos then
        next_pos = of_pos
        next_type = " of "
        next_len = 4
      elseif in_pos then
        next_pos = in_pos
        next_type = " in "
        next_len = 4
      end
      
      if next_pos then
        table.insert(separators, {pos = next_pos, type = next_type, len = next_len})
        search_pos = next_pos + 1
      else
        break
      end
    end
    
    dprint("Found %d separators", #separators)
    
    if #separators > 0 then
      -- Try to match against known area names
      local best_match = nil
      for i = 1, #separators do
        local sep = separators[i]
        local potential_area = after_vicinity:sub(sep.pos + sep.len)
        local area_lower = potential_area:lower()
        
        -- Check if this matches a known area name
        if AREA_LOOKUP[area_lower] then
          dprint("Found area match: '%s' at separator %d", potential_area, i)
          best_match = i
          break
        end
      end
      
      if best_match then
        local matched_sep = separators[best_match]
        room = after_vicinity:sub(1, matched_sep.pos - 1)
        area = after_vicinity:sub(matched_sep.pos + matched_sep.len)
        dprint("Using matched separator at pos %d: room='%s' area='%s'", matched_sep.pos, room, area)
      else
        -- Fallback to last separator if no area name match found
        dprint("No area name match found, using last separator")
        local last_sep = separators[#separators]
        room = after_vicinity:sub(1, last_sep.pos - 1)
        area = after_vicinity:sub(last_sep.pos + last_sep.len)
        dprint("Using last separator at pos %d: room='%s' area='%s'", last_sep.pos, room, area)
      end
    else
      dprint("No separators found in vicinity format")
      return
    end
  else
    -- Format: "in ROOM of/in AREA"
    local after_in = quest_part:match("in (.+)$")
    if not after_in then
      dprint("Failed to extract after 'in'")
      return
    end
    
    dprint("After in: %s", after_in)
    
    -- Find all " of " and " in " positions
    local separators = {}
    local search_pos = 1
    while true do
      local of_pos = after_in:lower():find(" of ", search_pos, true)
      local in_pos = after_in:lower():find(" in ", search_pos, true)
      
      local next_pos = nil
      local next_type = nil
      local next_len = 0
      
      if of_pos and in_pos then
        if of_pos < in_pos then
          next_pos = of_pos
          next_type = " of "
          next_len = 4
        else
          next_pos = in_pos
          next_type = " in "
          next_len = 4
        end
      elseif of_pos then
        next_pos = of_pos
        next_type = " of "
        next_len = 4
      elseif in_pos then
        next_pos = in_pos
        next_type = " in "
        next_len = 4
      end
      
      if next_pos then
        table.insert(separators, {pos = next_pos, type = next_type, len = next_len})
        search_pos = next_pos + 1
      else
        break
      end
    end
    
    dprint("Found %d separators", #separators)
    
    if #separators > 0 then
      -- Try to match against known area names
      local best_match = nil
      for i = 1, #separators do
        local sep = separators[i]
        local potential_area = after_in:sub(sep.pos + sep.len)
        local area_lower = potential_area:lower()
        
        -- Check if this matches a known area name
        if AREA_LOOKUP[area_lower] then
          dprint("Found area match: '%s' at separator %d", potential_area, i)
          best_match = i
          break
        end
      end
      
      if best_match then
        local matched_sep = separators[best_match]
        room = after_in:sub(1, matched_sep.pos - 1)
        area = after_in:sub(matched_sep.pos + matched_sep.len)
        dprint("Using matched separator at pos %d: room='%s' area='%s'", matched_sep.pos, room, area)
      else
        -- Fallback to last separator if no area name match found
        dprint("No area name match found, using last separator")
        local last_sep = separators[#separators]
        room = after_in:sub(1, last_sep.pos - 1)
        area = after_in:sub(last_sep.pos + last_sep.len)
        dprint("Using last separator at pos %d: room='%s' area='%s'", last_sep.pos, room, area)
      end
    else
      dprint("No separators found in simple format")
      return
    end
  end
  
  if area and room then
    -- Extract the target (mob name) from the original line
    local target = line:match("^You are on a quest to %w+ (.+) in the vicinity of") or 
                   line:match("^You are on a quest to %w+ (.+) in") or 
                   "target"
    target, room, area = clean_capture(target), clean_capture(room), clean_capture(area)
    ui_update("Quest", area, room, target, {clear=true})
    dprint("Quest info captured: target='%s' room='%s' area='%s'", target, room, area)
  else
    dprint("Failed to parse quest info - room='%s' area='%s'", tostring(room), tostring(area))
  end
end

-- Expeditions
function qt_exp_begin(name, line, wildcards) QT.exp_mode = true; clear_rows(); dprint("Expedition START") end
function qt_exp_line(name, line, wildcards)
  if not QT.exp_mode then return end
  line = strip_ansi(line or "")
  dprint("Expedition line: '%s'", line)
  
  local mob, area = string.match(line, EXP_LINE_CAP)
  if mob and area then
    area, mob = clean_capture(area), clean_capture(mob)
    ui_update("Expedition", area, "", mob, {clear=false})
    dprint("Expedition target captured: mob='%s' area='%s'", mob, area)
  else
    dprint("Expedition line did not match pattern")
  end
end
function qt_exp_end(name, line, wildcards) if QT.exp_mode then QT.exp_mode = false; dprint("Expedition END") end end

-- ===== Global Junkyards =====
local GJY = { active=false, buf="", expecting_cont=false }
local function _qt_gjy_enable_line(on) EnableTrigger("qt_gjy_line", on and true or false) end
local function _qt_gjy_enable_cont(on) EnableTrigger("qt_gjy_cont", on and true or false) end
local function _qt_collapse2(s) return (s or ""):gsub("[%s\r\n]+", " "):gsub("^%s+",""):gsub("%s+$","") end

local function _qt_gjy_try_parse()
  if not GJY.buf or GJY.buf == "" then return false end
  local s = _qt_collapse2(GJY.buf)
  
  dprint("GJY trying to parse: '%s'", s)
  
  -- Remove the leading number and period, and strip (here) and trailing period
  local without_num = s:match("^%d+%.%s+(.+)$")
  if not without_num then
    dprint("GJY: Could not strip number prefix")
    return false
  end
  
  -- Remove (here) marker and trailing periods/spaces
  without_num = without_num:gsub("%s*%([Hh][Ee][Rr][Ee]%)%s*", " ")
  without_num = without_num:gsub("%.%s*$", "")
  without_num = without_num:gsub("%s+$", "")
  
  -- Find all positions of " in " (case insensitive)
  local positions = {}
  local search_pos = 1
  while true do
    local found_pos = without_num:lower():find(" in ", search_pos, true)
    if not found_pos then break end
    table.insert(positions, found_pos)
    search_pos = found_pos + 1
  end
  
  if #positions < 2 then
    dprint("GJY: Need at least 2 ' in ' separators, found %d", #positions)
    return false
  end
  
  -- Use the FIRST and LAST " in " positions (skip any in the middle that are part of room name)
  local item_separator = positions[1]
  local area_separator = positions[#positions]
  
  local item = without_num:sub(1, item_separator - 1)
  local room = without_num:sub(item_separator + 4, area_separator - 1)
  local area = without_num:sub(area_separator + 4)
  
  if item and room and area then
    item, room, area = clean_capture(item), clean_capture(room), clean_capture(area)
    dprint("GJY parsed: item='%s' room='%s' area='%s'", item, room, area)
    if ui_update then ui_update("GJunkyard", area, room, item, {clear=false}) end
    GJY.buf, GJY.expecting_cont = "", false
    _qt_gjy_enable_cont(false)
    _qt_gjy_enable_line(true)
    return true
  end
  
  dprint("GJY parse failed")
  return false
end

function qt_gjy_begin(name, line, wildcards)
  GJY.active, GJY.buf, GJY.expecting_cont = true, "", false
  _qt_gjy_enable_line(true)
  _qt_gjy_enable_cont(false)
  if clear_rows then clear_rows() end
  dprint("Global Junkyard BEGIN")
end

function qt_gjy_line(name, line, wildcards)
  if not GJY.active then return end
  dprint("GJY line: '%s'", line)
  
  -- If we have a previous buffer, this might be a new item, so try to parse the buffer first
  if GJY.buf ~= "" and line:match("^%s*%d+%.") then
    dprint("New item detected, parsing previous buffer first")
    _qt_gjy_try_parse()
  end
  
  GJY.buf = (GJY.buf == "" and line or (GJY.buf .. " " .. line))
  GJY.expecting_cont = true
  _qt_gjy_enable_cont(true)
  _qt_gjy_enable_line(true)
  _qt_gjy_try_parse()
end

function qt_gjy_cont(name, line, wildcards)
  if not (GJY.active and GJY.expecting_cont) then return end
  
  dprint("GJY cont: '%s'", line)
  
  -- Check for end markers
  if line:match("^%s*-+%s*$") or line:match("^%s*$") then
    dprint("GJY end marker detected")
    -- Try to parse any remaining buffer
    if GJY.buf ~= "" then
      _qt_gjy_try_parse()
    end
    GJY.active, GJY.buf, GJY.expecting_cont = false, "", false
    _qt_gjy_enable_line(false)
    _qt_gjy_enable_cont(false)
    return
  end
  
  -- Check if this is a new numbered item (which means previous item is complete)
  if line:match("^%s*%d+%.") then
    dprint("New item number detected, parsing previous buffer")
    _qt_gjy_try_parse()
    -- Start new buffer with this line
    GJY.buf = line
    _qt_gjy_try_parse()
  else
    -- This is a continuation of the current item
    GJY.buf = (GJY.buf == "" and line or (GJY.buf .. " " .. line))
    _qt_gjy_try_parse()
  end
end

-- ===== Timed Junkyard Quest =====
local JY = { active=false, buf="", expecting_cont=false }
local function _qt_jy_enable_line(on) EnableTrigger("qt_jy_line", on and true or false) end
local function _qt_jy_enable_cont(on) EnableTrigger("qt_jy_cont", on and true or false) end
local function _qt_jy_enable_end(on) EnableTrigger("qt_jy_end", on and true or false) end

local function _qt_jy_try_parse()
  if not JY.buf or JY.buf == "" then return false end
  local s = _qt_collapse2(JY.buf)
  
  dprint("JY trying to parse: '%s'", s)
  
  -- Remove the leading [#]
  local without_num = s:match("^%[%s*%d+%s*%]%s+(.+)$")
  if not without_num then
    dprint("JY: Could not strip bracket prefix")
    return false
  end
  
  -- Remove (here) marker and trailing periods/spaces
  without_num = without_num:gsub("%s*%([Hh][Ee][Rr][Ee]%)%s*", " ")
  without_num = without_num:gsub("%.%s*$", "")
  without_num = without_num:gsub("%s+$", "")
  
  -- Find all positions of " in " (case insensitive)
  local positions = {}
  local search_pos = 1
  while true do
    local found_pos = without_num:lower():find(" in ", search_pos, true)
    if not found_pos then break end
    table.insert(positions, found_pos)
    search_pos = found_pos + 1
  end
  
  if #positions < 2 then
    dprint("JY: Need at least 2 ' in ' separators, found %d", #positions)
    return false
  end
  
  -- Use the FIRST and LAST " in " positions (skip any in the middle that are part of room name)
  local item_separator = positions[1]
  local area_separator = positions[#positions]
  
  local item = without_num:sub(1, item_separator - 1)
  local room = without_num:sub(item_separator + 4, area_separator - 1)
  local area = without_num:sub(area_separator + 4)
  
  if item and room and area then
    item, room, area = clean_capture(item), clean_capture(room), clean_capture(area)
    dprint("JY parsed successfully: item='%s' room='%s' area='%s'", item, room, area)
    ui_update("Junkyard", area, room, item, {clear=false})
    JY.buf, JY.expecting_cont = "", false
    _qt_jy_enable_cont(false)
    _qt_jy_enable_line(true)
    return true
  end
  
  dprint("JY parse failed - may need continuation")
  return false
end

function qt_jy_begin(name, line, wildcards)
  JY.active, JY.buf, JY.expecting_cont = true, "", false
  _qt_jy_enable_line(true)
  _qt_jy_enable_cont(false)
  _qt_jy_enable_end(true)
  clear_rows()
  dprint("Timed Junkyard Quest START")
end

function qt_jy_line(name, line, wildcards)
  if not JY.active then return end
  dprint("JY line received: '%s'", line)
  
  -- If we have a previous buffer and see a new bracketed item, parse the buffer first
  if JY.buf ~= "" and line:match("^%s*%[%s*%d+%s*%]") then
    dprint("New item detected, parsing previous buffer first")
    _qt_jy_try_parse()
  end
  
  JY.buf = (JY.buf == "" and line or (JY.buf .. " " .. line))
  JY.expecting_cont = true
  _qt_jy_enable_cont(true)
  _qt_jy_enable_line(true)
  _qt_jy_try_parse()
end

function qt_jy_cont(name, line, wildcards)
  if not (JY.active and JY.expecting_cont) then return end
  
  dprint("JY cont received: '%s'", line)
  
  -- Check for end marker (blank line)
  if line:match("^%s*$") then
    dprint("JY blank line - ending")
    if JY.buf ~= "" then
      _qt_jy_try_parse()
    end
    JY.active, JY.buf, JY.expecting_cont = false, "", false
    _qt_jy_enable_line(false)
    _qt_jy_enable_cont(false)
    _qt_jy_enable_end(false)
    return
  end
  
  -- Check if this is a new numbered item
  if line:match("^%s*%[%s*%d+%s*%]") then
    dprint("New bracketed item in continuation, parsing previous first")
    _qt_jy_try_parse()
    JY.buf = line
    _qt_jy_try_parse()
  else
    -- Continuation of current item
    JY.buf = (JY.buf == "" and line or (JY.buf .. " " .. line))
    _qt_jy_try_parse()
  end
end

function qt_jy_end(name, line, wildcards)
  if JY.active then
    dprint("JY end trigger: '%s'", line)
    
    -- Try to parse any remaining buffer before ending
    if JY.buf ~= "" then
      dprint("Parsing remaining buffer before end")
      _qt_jy_try_parse()
    end
    
    JY.active, JY.buf, JY.expecting_cont = false, "", false
    _qt_jy_enable_line(false)
    _qt_jy_enable_cont(false)
    _qt_jy_enable_end(false)
    dprint("Timed Junkyard Quest END")
  end
end

-- ===== Global Quest targets =====
local GQ = { active=false }
local function _qt_gq_enable_line(on) EnableTrigger("qt_gq_line", on and true or false) end
local function _qt_gq_enable_end(on) EnableTrigger("qt_gq_end", on and true or false) end

function qt_gq_begin(name, line, wildcards)
  GQ.active = true
  _qt_gq_enable_line(true)
  _qt_gq_enable_end(true)
  clear_rows()
  dprint("Global Quest targets START")
end

function qt_gq_line(name, line, wildcards)
  if not GQ.active then return end
  line = strip_ansi(line or "")
  
  dprint("GQ Line raw: '%s'", line)
  
  if line:match("^%s*%d+%.%s*%?+%s*$") then
    dprint("Skipping placeholder line: %s", line)
    return
  end
  
  -- Try patterns in order of specificity
  -- Pattern 1: mob in room in area (strip trailing period)
  local mob, room, area = line:match("^%s*%d+%.%s+(.-)%s+[Ii]n%s+(.-)%s+[Ii]n%s+(.-)%.?%s*$")
  if mob and room and area then
    mob, room, area = clean_capture(mob), clean_capture(room), clean_capture(area)
    -- Remove any trailing period from area
    area = area:gsub("%.$", "")
    ui_update("Global", area, room, mob, {clear=false})
    dprint("Global Quest target (with room): mob='%s' room='%s' area='%s'", mob, room, area)
    return
  end
  
  -- Pattern 2: mob in area (no room, strip trailing period)
  local mob2, area2 = line:match("^%s*%d+%.%s+(.-)%s+[Ii]n%s+(.-)%.?%s*$")
  if mob2 and area2 then
    mob2, area2 = clean_capture(mob2), clean_capture(area2)
    -- Remove any trailing period from area
    area2 = area2:gsub("%.$", "")
    ui_update("Global", area2, "", mob2, {clear=false})
    dprint("Global Quest target: mob='%s' area='%s'", mob2, area2)
    return
  end
  
  dprint("GQ Line failed to parse")
end

function qt_gq_end(name, line, wildcards)
  if GQ.active then
    GQ.active = false
    _qt_gq_enable_line(false)
    _qt_gq_enable_end(false)
    dprint("Global Quest targets END")
  end
end

-- ===== Death removal =====
local function remove_row_by_mob(mobline)
  if not mobline or mobline == "" then return false end
  local key = norm_lower(strip_ansi(mobline))
  
  for i=1,#QT.rows do
    local r = QT.rows[i]
    if r and norm_lower(r.mob or "") == key then
      table.remove(QT.rows, i)
      
      -- Check if this was the last quest target
      if #QT.rows == 0 then
        QT.quest_complete = true
        dprint("Last quest target killed - quest complete!")
      end
      
      ui_draw()
      dprint("Removed row (exact match) for death: %s", mobline)
      return true
    end
  end
  
  for i=1,#QT.rows do
    local r = QT.rows[i]
    local mob_normalized = norm_lower(r.mob or "")
    if mob_normalized ~= "" and mob_normalized:find(key, 1, true) then
      table.remove(QT.rows, i)
      
      -- Check if this was the last quest target
      if #QT.rows == 0 then
        QT.quest_complete = true
        dprint("Last quest target killed - quest complete!")
      end
      
      ui_draw()
      dprint("Removed row (partial match) for death: %s matched %s", mobline, r.mob)
      return true
    end
  end
  
  return false
end

function qt_on_death(name, line, wildcards)
  local raw = line or ""
  local mob = raw:match("^%s*(.+)%s+is%s+dead!")
  if mob then
    if not remove_row_by_mob(mob) then
      dprint("Death seen but no matching row: %s", mob)
    end
  end
end

-- ===== Quest Turn-in =====
function qt_on_quest_turnin(name, line, wildcards)
  dprint("Quest turned in")
  QT.quest_complete = false
  ui_draw()
end

-- ===== Item pickup removal =====
local function remove_row_by_item(itemline)
  if not itemline or itemline == "" then return false end
  local key = norm_lower(strip_ansi(itemline))
  
  dprint("Item pickup: looking for '%s'", key)
  
  -- Try exact match first
  for i=1,#QT.rows do
    local r = QT.rows[i]
    local row_item = norm_lower(r.mob or "")
    dprint("  Comparing with row %d: '%s'", i, row_item)
    
    if row_item == key then
      table.remove(QT.rows, i)
      
      -- Check if this was the last junkyard item
      if #QT.rows == 0 then
        QT.quest_complete = true
        dprint("Last junkyard item collected - quest complete!")
      end
      
      ui_draw()
      dprint("Removed row (exact match) for item pickup: %s", itemline)
      return true
    end
  end
  
  -- Try partial match (item name contains pickup text OR pickup text contains item name)
  for i=1,#QT.rows do
    local r = QT.rows[i]
    local item_normalized = norm_lower(r.mob or "")
    
    if item_normalized ~= "" then
      -- Check both directions for partial matches
      if item_normalized:find(key, 1, true) or key:find(item_normalized, 1, true) then
        table.remove(QT.rows, i)
        
        -- Check if this was the last junkyard item
        if #QT.rows == 0 then
          QT.quest_complete = true
          dprint("Last junkyard item collected - quest complete!")
        end
        
        ui_draw()
        dprint("Removed row (partial match) for item pickup: '%s' matched '%s'", itemline, r.mob)
        return true
      end
    end
  end
  
  dprint("No matching item found in tracker for: %s", itemline)
  return false
end

function qt_on_item_pickup(name, line, wildcards)
  local item = wildcards[1] or ""
  if item ~= "" then
    dprint("Item pickup trigger fired: %s", item)
    if not remove_row_by_item(item) then
      dprint("Item pickup seen but no matching row: %s", item)
    end
  end
end

-- ===== Where command auto-navigation =====
local WHERE = { active=false, found_first=false, seen_blank=false }
local function _qt_where_enable_line(on) EnableTrigger("qt_where_line", on and true or false) end
local function _qt_where_enable_end(on) EnableTrigger("qt_where_end", on and true or false) end

function qt_where_begin(name, line, wildcards)
  WHERE.active = true
  WHERE.found_first = false
  WHERE.seen_blank = false
  _qt_where_enable_line(true)
  _qt_where_enable_end(true)
  dprint("Where search detected, waiting for first result")
end

function qt_where_line(name, line, wildcards)
  if not WHERE.active or WHERE.found_first then return end
  
  local raw_line = line or ""
  line = strip_ansi(raw_line)
  
  if line:match("^%s*$") then return end
  
  local mob, room = line:match("^(.-)%s%s%s%s%s%s%s%s%s%s+(.+)$")
  if not mob then mob, room = line:match("^(.-)%s%s%s%s%s+(.+)$") end
  if not mob then mob, room = line:match("^(.-)%s%s+(.+)$") end
  
  if mob and room then
    mob = clean_capture(mob)
    room = clean_capture(room)
    room = room:gsub("%s*%([xX]%d+%)%s*$", "")
    
    WHERE.found_first = true
    dprint("Parsed: mob='%s' room='%s'", mob, room)
    
    local room_lower = norm_lower(room)
    Execute("mapper find " .. room_lower)
  end
end

function qt_where_end(name, line, wildcards)
  if WHERE.active then
    if WHERE.seen_blank or WHERE.found_first then
      WHERE.active = false
      WHERE.found_first = false
      WHERE.seen_blank = false
      _qt_where_enable_line(false)
      _qt_where_enable_end(false)
      dprint("Where search ended")
    else
      WHERE.seen_blank = true
    end
  end
end

-- ===== Lifecycle =====
function OnPluginInstall() ui_show() end
function OnPluginEnable()  ui_show() end
function OnPluginDisable() ui_hide() end
function OnPluginSaveState() ui_save_pos() end

-- ===== Commands =====
local function echo(s) Note("[QT] "..s) end

local function show_help()
  ColourNote("cyan", "", string.rep("=", 76))
  ColourNote("white", "", "                    Erion Quest Tracker v18.01")
  ColourNote("cyan", "", string.rep("=", 76))
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "OVERVIEW:")
  ColourNote("white", "", "  Automatically tracks quests, junkyard tasks, and expeditions with")
  ColourNote("white", "", "  a modern visual interface featuring clickable navigation and actions.")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "COMMANDS:")
  ColourNote("lime", "", "  qt on             ", "white", "", "- Show the quest tracker window")
  ColourNote("lime", "", "  qt off            ", "white", "", "- Hide the quest tracker window")
  ColourNote("lime", "", "  qt reset          ", "white", "", "- Reset window size and position")
  ColourNote("lime", "", "  qt clear          ", "white", "", "- Clear all tracked quests")
  ColourNote("lime", "", "  qt debug on|off   ", "white", "", "- Toggle debug output")
  ColourNote("lime", "", "  qt help           ", "white", "", "- Show this help file")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "HOW IT WORKS:")
  ColourNote("white", "", "  The tracker automatically detects when you request quests:")
  ColourNote("white", "", "    * Regular Quest:    ", "lime", "", "quest request")
  ColourNote("white", "", "    * Junkyard Quest:   ", "lime", "", "quest junkyard")
  ColourNote("white", "", "    * Expedition:       ", "lime", "", "quest expedition")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "INTERACTIVE FEATURES:")
  ColourNote("white", "", "  Click on any blue text in the tracker:")
  ColourNote("cyan", "", "    Area Name     ", "white", "", "- Navigate to area entrance")
  ColourNote("cyan", "", "    Room Name     ", "white", "", "- Find room with mapper")
  ColourNote("cyan", "", "    Target/Mob    ", "white", "", "- Locate with 'where' command")
  ColourNote("white", "", "")
  ColourNote("white", "", "  Click the action buttons:")
  ColourNote("cyan", "", "    [Kill] Button ", "white", "", "- Attack the target mob")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "AUTO-REMOVAL:")
  ColourNote("white", "", "  * Quest targets removed automatically when killed")
  ColourNote("white", "", "  * Junkyard items removed when picked up")
  ColourNote("white", "", "  * Global quests cleared when you win")
  ColourNote("white", "", "  * Shows ", "red", "", "\"Return to Quest Giver...\"", "white", "", " when all targets complete")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "WINDOW CONTROLS:")
  ColourNote("white", "", "  * Drag the title bar to move the window")
  ColourNote("white", "", "  * Drag bottom-right corner to resize")
  ColourNote("white", "", "  * Window position and size saved automatically")
  ColourNote("yellow", "", "")
  ColourNote("yellow", "", "TIPS:")
  ColourNote("white", "", "  * Kill button uses smart parsing (e.g., 'evil knight' -> 'kill knight')")
  ColourNote("white", "", "  * Supports multiple quest targets (expeditions show all mobs)")
  ColourNote("white", "", "  * Click Area to auto-navigate to nexus entrance")
  ColourNote("cyan", "", string.rep("=", 76))
end

function qt_cmd(args)
  local a={} for t in string.gmatch(args or "", "[^%s]+") do table.insert(a,t) end
  local sub=(a[1] or ""):lower()
  if sub=="on" then ui_show(); echo("UI: shown")
  elseif sub=="off" then ui_hide(); echo("UI: hidden")
  elseif sub=="reset" then UI.w,UI.h=750,280; ui_show(); ui_save_pos(); echo("UI: reset")
  elseif sub=="clear" then clear_rows(); ui_draw(); echo("Rows cleared")
  elseif sub=="help" or sub=="?" then show_help()
  elseif sub=="debug" then 
    local debug_arg = (a[2] or ""):lower()
    if debug_arg == "on" or debug_arg == "1" then
      QT.debug = true
      echo("Debug: ON")
    elseif debug_arg == "off" or debug_arg == "0" then
      QT.debug = false
      echo("Debug: OFF")
    else
      QT.debug = not QT.debug
      echo("Debug: " .. (QT.debug and "ON" or "OFF"))
    end
  elseif sub=="testtrack" then
    local text=args:match("testtrack%s+(.+)"); if not text then echo("Usage: qt testtrack The sceptre has been tracked to <Room> in <Area>."); return end
    qt_parse_quest("", text, {})
  elseif sub=="testitem" then
    local text=args:match("testitem%s+(.+)"); if not text then echo("Usage: qt testitem ... that <item>'s now in <Room> in <Area> ..."); return end
    qt_parse_quest("", text, {})
  elseif sub=="testjunk" then
    local text=args:match("testjunk%s+(.+)"); if not text then echo("Usage: qt testjunk [ 1] <item> in <Room> in <Area>"); return end
    JY.active=true; qt_jy_line("", text, {}); JY.active=false
  elseif sub=="testquestinfo" then
    local text=args:match("testquestinfo%s+(.+)"); if not text then echo("Usage: qt testquestinfo You are on a quest to recover the fabled ring in <Room> of <Area>."); return end
    qt_parse_quest_info("", text, {})
  elseif sub=="testglobal" then
    local text=args:match("testglobal%s+(.+)"); if not text then echo("Usage: qt testglobal 1. <mob> in <area>"); return end
    GQ.active=true; qt_gq_line("", text, {}); GQ.active=false
  elseif sub=="test" then
    local text=args:match("test%s+(.+)"); if not text then echo("Usage: qt test <full quest line>"); return end
    qt_parse_quest("", text, {})
  elseif sub=="testexp" then
    local text=args:match("testexp%s+(.+)"); if not text then echo("Usage: qt testexp Find and kill <mob> in <area>."); return end
    QT.exp_mode=true; qt_exp_line("", text, {})
  elseif sub=="testdeath" then
    local m=args:match("testdeath%s+(.+)"); if not m then echo("Usage: qt testdeath <mob>"); return end
    qt_on_death("", m.." is dead! R.I.P.", {})
  elseif sub=="testpickup" then
    local item=args:match("testpickup%s+(.+)"); if not item then echo("Usage: qt testpickup <item>"); return end
    qt_on_item_pickup("", "You get " .. item .. " from the ground.", {item})
  else
    echo("Commands: qt on|off|reset|clear|debug on|off|help")
    echo("Type 'qt help' for detailed documentation")
  end
end

-- ===== Global Quest Win (defined at end after all functions exist) =====
function qt_global_win(name, line, wildcards)
  dprint("Global quest win detected")
  -- Clear all Global quest rows when winning
  for i=#QT.rows,1,-1 do
    local r = QT.rows[i]
    if r and r.type == "Global" then
      table.remove(QT.rows, i)
      dprint("Removed Global quest row: %s", r.mob or "")
    end
  end
  -- Reset quest complete flag so status shows "No active quests"
  QT.quest_complete = false
  if UI and UI.visible then 
    ui_draw() 
  end
  dprint("Global quest completed - cleared all Global rows and reset status")
end

-- ===== Gods Forsaken Recovery =====
function qt_gods_forsaken(name, line, wildcards)
  dprint("Gods have forsaken - attempting recovery")
  if QT.pending_area and QT.pending_area ~= "" then
    local area = QT.pending_area
    Note("[QT] Attempting to recover home visit via hag entrance...")
    Send("enter hag")
    Send("home visit kaeldrys")
    Send("nexus enter " .. area)
    dprint("Recovery sequence sent for area: %s", area)
  else
    dprint("No pending area to retry")
  end
end

  ]]>
  </script>
  
</muclient>